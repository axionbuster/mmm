<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>M.Collision.Internal.March</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">mmm-0.1.0.0: Minecraft 1.21.4 implementation in Haskell</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/M.Collision.Internal.March.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) axionbuster 2025</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>GHC2021</td></tr></table><p class="caption">M.Collision.Internal.March</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Implements ray marching algorithm for finding intersections with grid points.
 Used for precise collision detection in voxel-based environments.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:March">March</a> (f :: <a href="../base-4.20.0.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.20.0.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a = <a href="#v:March">March</a> {<ul class="subs"><li><a href="#v:mtot">mtot</a> :: a</li><li><a href="#v:mpct">mpct</a> :: f a</li><li><a href="#v:mict">mict</a> :: [f <a href="../base-4.20.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li></ul>}</li><li class="src short"><a href="#v:march">march</a> :: (<a href="../base-4.20.0.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, Representable f, Rep f <a href="../base-4.20.0.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> E f, <a href="../base-4.20.0.0/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a, Epsilon a) =&gt; f a -&gt; f a -&gt; [<a href="M-Collision-Internal-March.html#t:March" title="M.Collision.Internal.March">March</a> f a]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:March" class="def">March</a> (f :: <a href="../base-4.20.0.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.20.0.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a <a href="src/M.Collision.Internal.March.html#March" class="link">Source</a> <a href="#t:March" class="selflink">#</a></p><div class="doc"><p><code><a href="M-Collision-Internal-March.html#v:march" title="M.Collision.Internal.March">march</a></code> data structure</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:March" class="def">March</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:mtot" class="def">mtot</a> :: a</dfn><div class="doc"><p>total time</p></div></li><li><dfn class="src"><a id="v:mpct" class="def">mpct</a> :: f a</dfn><div class="doc"><p>grid intersection (lies on boundaries of grid cells)</p><p>'pct' is for 'punctum', which is Latin for point</p></div></li><li><dfn class="src"><a id="v:mict" class="def">mict</a> :: [f <a href="../base-4.20.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</dfn><div class="doc"><p>grid points (e.g., cubes, squares) intersected</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:march" class="def">march</a> <a href="src/M.Collision.Internal.March.html#march" class="link">Source</a> <a href="#v:march" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.20.0.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, Representable f, Rep f <a href="../base-4.20.0.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> E f, <a href="../base-4.20.0.0/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a, Epsilon a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; f a</td><td class="doc"><p>starting point. use either f ~ <code>V2</code> or f ~ <code>V3</code> or other <code>Representable</code>
 vector types where 'fmap f x' agrees with</p><pre><code>tabulate</code> \i -&gt; f (<code>index</code> x i))</pre></td></tr><tr><td class="src">-&gt; f a</td><td class="doc"><p>direction (no need to be normalized)</p></td></tr><tr><td class="src">-&gt; [<a href="M-Collision-Internal-March.html#t:March" title="M.Collision.Internal.March">March</a> f a]</td><td class="doc"><p>list of (total time, point, [grid point]) pairs</p></td></tr></table></div><div class="doc"><p>march along a line segment, finding all intersections
 with grid squares or cubes (depending on the dimensionality)
 as well as the time it takes to reach each intersection
 and the cubes that are intersected</p><p>the cubes are represented by their low corner coordinates</p><p>in 2D, when a point is intersected, the two squares about
 the point that the line (that extends rhe ray) does NOT
 intersect will be included. it's because this routine is used
 for collision detection</p><p>in 3D, there are many edge cases, but generally only the cubes
 needed for collision detection are returned. so about
 a corner, three cubes will be returned; abour an edge,
 two (assuming ray is not parallel to a coordinate plane)</p><p>a compensated sum is used to reduce floating point error.
 the compensation applies to the coordinates and times</p><p>the returned list being infinite, it is recommended to
 use <code><a href="../base-4.20.0.0/Data-List.html#v:take" title="Data.List">take</a></code> to limit the number of points to be computed</p><p>the starting point is not included in the list unless it
 happens to be a grid intersection</p><p>if the direction is (near) zero, or if any component of the
 direction is not finite, then the function will return an empty list</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>