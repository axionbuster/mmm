{-# OPTIONS_GHC -Wno-missing-export-lists #-}

-- | Packet definitions for the V769 (Java 1.21.4) protocol.
--
-- WARNING: Much of this module was generated by AI under human guidance.
-- It is not guaranteed to be correct.
module M.J.V769.Defs where

import Control.DeepSeq
import Data.Bits
import Data.ByteString (ByteString)
import Data.Data
import Data.Hashable
import Data.Int
import Data.Serde.QQ
import Data.Text (Text)
import Data.UUID.Types
import Data.Vector qualified as V
import Data.Word
import GHC.Generics
import Language.Haskell.TH.Syntax (Lift)
import M.J.Chunk.Net
import M.J.Misc
import M.J.NBT
import M.J.Position
import M.J.TextComponent
import M.LEB
import M.Pack
import Prelude hiding (id)

-- sum types cannot be defined in serde just yet, so
-- we define them here

data ChatMode = CMEnabled | CMCommandsOnly | CMHidden
  deriving stock (Eq, Ord, Show, Enum, Bounded, Generic, Data, Typeable, Lift)
  deriving anyclass (NFData, Hashable)

data ParticleStatus = PSAll | PSDecreased | PSMinimal
  deriving stock (Eq, Ord, Show, Enum, Bounded, Generic, Data, Typeable, Lift)
  deriving anyclass (NFData, Hashable)

[serde|
.derive
  Eq Ord Show Generic NFData Data Typeable

-- examples

data StatusResponse
  jsonresponse :: Text

data StatusRequest

-- to define LoginSuccess, need to define 'Property' first
-- also, assume OverloadedRecordDot is enabled, as well as
-- DuplicateRecordFields and DisambiguateRecordFields, so that
-- multiple records can have the same field name

data LoginSuccess_Property
  name :: Text
  value :: Text
  signature :: Maybe Text

-- SetCompression shows the example of using a via clause
-- to define how to serialize/deserialize a field, without
-- leaking the implementation details of the serialization
-- format to the user

-- though we can use a newtype, because of an issue in deriving
-- Generic using DerivingVia, we can't use it here until
-- the ".no" feature (which disables deriving specific instances)
-- is implemented
data SetCompression
  getcompressionthreshold :: Int32 via VarInt

-- in the below example we use shadowing to borrow the
-- Pack and Unpack implementation through LEB Int32,
-- which is equal to VarInt

data LoginPluginRequest
  messageid :: Int32 via LEB Int32
  channel :: Text
  data_ :: ByteString via TakeRest -- if Coercible, ok

data LoginStart
  name :: Text
  uuid :: UUID

-- 'Identifier' isn't to be exposed to the user (yet);
-- I haven't made up my mind about that

data CookieRequestConfiguration
  key :: Text via Identifier

-- we don't ever use raw lists ([...]) for serialization/deserialization.
-- we use Vectors (V.Vector or VU.Vector)

data RegistryData
  regid :: Text via Identifier
  entries :: V.Vector RegistryData_Entry

data RegistryData_Entry
  id :: Text via Identifier
  data_ :: Maybe Tg -- NBT = Tg

-- some more complicated bits are shown here
-- sum types: we can't define sum types here yet, so
--  for now, assume they are defined elsewhere
-- EnumIndex i a: newtype over 'a' but uses integral type 'i' to
--  represent it. used for simple sum types
-- Bitwise i a: newtype over 'a', a product of booleans.
--  represents it as a bit set over the integral type 'i'.

data ClientInformationConfiguration
  locale :: Text
  viewdistance :: Int8
  chatmode :: ChatMode via EnumIndex VarInt ChatMode
  chatcolors :: Bool
  displayedskinparts :: DisplayedSkinParts via Bitwise Word8 DisplayedSkinParts
  mainhandright :: Bool
  enabletextfiltering :: Bool
  allowserverlistings :: Bool
  particlestatus :: ParticleStatus via EnumIndex VarInt ParticleStatus

data DisplayedSkinParts
  cape :: Bool
  jacket :: Bool
  leftsleeve :: Bool
  rightsleeve :: Bool
  leftpants :: Bool
  rightpants :: Bool
  hat :: Bool

-- other newtype examples

data UpdateEntityRotation
  id :: Int32 via VarInt
  -- arguably, we need to use Double as the underlying type
  -- instead of Int8. but whatever, it's just an example
  yaw :: Int8 via Int8Angle
  pitch :: Int8 via Int8Angle
  onground :: Bool

-- using dummy types: Slot (Data), Text Component (NBT/JSON), etc.
-- some shim types have been defined, so we can use them here

data CombatDeath
  id :: Int32 via VarInt
  message :: TextComponent

-- Basic handshaking/status packets
data HandshakePacket
  protocolversion :: Int32 via VarInt
  serveraddress :: Text 
  serverport :: Word16
  nextstate :: Int32 via VarInt

-- Login packets
data LoginDisconnect
  reason :: TextComponent

data EncryptionRequest
  serverid :: Text
  publickey :: ByteString
  verifytoken :: ByteString
  shouldauthenticate :: Bool

data LoginSuccess
  uuid :: UUID
  username :: Text
  properties :: V.Vector LoginSuccess_Property

data LoginPluginResponse
  messageid :: Int32 via VarInt
  successful :: Bool
  data_ :: Maybe ByteString

-- Play state packets
data BundleDelimiter -- empty packet

data SpawnEntity
  entityid :: Int32 via VarInt
  entityuuid :: UUID
  type_ :: Int32 via VarInt
  x :: Double
  y :: Double
  z :: Double
  pitch :: Int8 via Int8Angle
  yaw :: Int8 via Int8Angle
  headyaw :: Int8 via Int8Angle
  data_ :: Int32 via VarInt
  velocityx :: Int16
  velocityy :: Int16
  velocityz :: Int16

data BlockUpdate
  location :: Position 
  blockid :: Int32 via VarInt

data ChatMessage
  message :: Text
  timestamp :: Int64
  salt :: Int64
  signature :: Maybe ByteString
  messagecount :: Int32 via VarInt
  acknowledged :: FixedBitset 20

data ChunkBiomes
  x :: Int32
  z :: Int32
  data_ :: ChunkData

data PlayerPosition
  x :: Double
  y :: Double
  z :: Double
  yaw :: Float
  pitch :: Float
  flags :: TeleportFlags via Bitwise Word8 TeleportFlags
  teleportid :: Int32 via VarInt
|]

-- another thing. to use Bitwise, we need to derive Bitreppable
-- for the type. Bitreppable takes two type parameters: the
-- integral type to use, and the product type to represent as bits.

-- the standard way is to make a blanket instance like so:

instance
  (Bits i, Integral i, Pack i, Unpack i) =>
  Bitreppable i DisplayedSkinParts

-- lastly, we invoke Template Haskell to generate the instances

-- provided by "th-serde": Data.Serde.QQ
runusercoercion
  -- provided by M.Pack
  derivepackunpack
  -- preparations for shadow types
  [''Generic, ''Pack, ''Unpack]
