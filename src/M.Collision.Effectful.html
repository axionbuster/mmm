<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621680371602"><span id="local-6989586621680371603"><span id="local-6989586621680371604"><span id="local-6989586621680371605"></span></span></span></span><span class="hs-comment">-- |</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- Module: M.Collision.Effectful</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Description: Effectful collision detection and resolution system</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Copyright: (c) axionbuster, 2025</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- License: BSD-3-Clause</span><span>
</span><span id="line-6"></span><span class="hs-comment">--</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Provides the core collision detection and resolution system with effects.</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Handles block-based collision detection, movement resolution, and ground contact states.</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- = Parts</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- 1. The 'GetBlock' effect</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- 2. The 'Resolve' data type and 'resolve' function (the main part)</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- 3. The 'NewlyTouchingGround' data type and 'updonground' function</span><span>
</span><span id="line-15"></span><span class="hs-comment">--</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- = Usage</span><span>
</span><span id="line-17"></span><span class="hs-comment">--</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- 1. Use 'getblock' to get a block's shape at integer coordinates</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- 2. Use 'resolve' to detect and resolve collision</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- 3. Use 'updonground' to update the on-ground status (from \#2)</span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html"><span class="hs-identifier">M.Collision.Effectful</span></a></span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier">GetBlock</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier">getblock</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier">Resolve</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#resolve"><span class="hs-identifier">resolve</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#_respos"><span class="hs-identifier">_respos</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#_resdis"><span class="hs-identifier">_resdis</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#_restou"><span class="hs-identifier">_restou</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier">NewlyTouchingGround</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#updonground"><span class="hs-identifier">updonground</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#islanding"><span class="hs-identifier">islanding</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#istakingoff"><span class="hs-identifier">istakingoff</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-34"></span><span class="hs-keyword">where</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Lens</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">index</span></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Fix</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Bits</span></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Coerce</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Rep</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Hashable</span></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">nub</span></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Semigroup</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Traversable</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Dispatch.Dynamic</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Exception</span></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Reader.Static</span></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Linear</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="M.Collision.Internal.Face.html"><span class="hs-identifier">M.Collision.Internal.Face</span></a></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="M.Collision.Internal.March.html"><span class="hs-identifier">M.Collision.Internal.March</span></a></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="M.Collision.Pure.html"><span class="hs-identifier">M.Collision.Pure</span></a></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">break</span></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="annot"><span class="hs-comment">-- | collision resolution data type</span></span><span>
</span><span id="line-61"></span><span class="hs-keyword">data</span><span> </span><span id="Resolve"><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-var">Resolve</span></a></span></span><span> </span><span id="local-6989586621680371286"><span class="annot"><a href="#local-6989586621680371286"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Resolve"><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-var">Resolve</span></a></span></span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="hs-comment">-- | final position</span></span><span>
</span><span id="line-63"></span><span>    </span><span id="respos"><span class="annot"><span class="annottext">forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var hs-var">respos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371286"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><span class="hs-comment">-- | remaining displacement</span></span><span>
</span><span id="line-65"></span><span>    </span><span id="resdis"><span class="annot"><span class="annottext">forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var hs-var">resdis</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371286"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><span class="hs-comment">-- | what to do with the on-ground status</span></span><span>
</span><span id="line-67"></span><span>    </span><span id="restou"><span class="annot"><span class="annottext">forall a. Resolve a -&gt; NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var hs-var">restou</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-type">NewlyTouchingGround</span></a></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680371640"><span id="local-6989586621680371649"><span id="local-6989586621680371653"><span class="annot"><span class="annottext">Int -&gt; Resolve a -&gt; String -&gt; String
[Resolve a] -&gt; String -&gt; String
Resolve a -&gt; String
(Int -&gt; Resolve a -&gt; String -&gt; String)
-&gt; (Resolve a -&gt; String)
-&gt; ([Resolve a] -&gt; String -&gt; String)
-&gt; Show (Resolve a)
forall a. Show a =&gt; Int -&gt; Resolve a -&gt; String -&gt; String
forall a. Show a =&gt; [Resolve a] -&gt; String -&gt; String
forall a. Show a =&gt; Resolve a -&gt; String
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; Resolve a -&gt; String -&gt; String
showsPrec :: Int -&gt; Resolve a -&gt; String -&gt; String
$cshow :: forall a. Show a =&gt; Resolve a -&gt; String
show :: Resolve a -&gt; String
$cshowList :: forall a. Show a =&gt; [Resolve a] -&gt; String -&gt; String
showList :: [Resolve a] -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371659"><span id="local-6989586621680371666"><span class="annot"><span class="annottext">Resolve a -&gt; Resolve a -&gt; Bool
(Resolve a -&gt; Resolve a -&gt; Bool)
-&gt; (Resolve a -&gt; Resolve a -&gt; Bool) -&gt; Eq (Resolve a)
forall a. Eq a =&gt; Resolve a -&gt; Resolve a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; Resolve a -&gt; Resolve a -&gt; Bool
== :: Resolve a -&gt; Resolve a -&gt; Bool
$c/= :: forall a. Eq a =&gt; Resolve a -&gt; Resolve a -&gt; Bool
/= :: Resolve a -&gt; Resolve a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371671"><span id="local-6989586621680371673"><span class="annot"><span class="annottext">(forall x. Resolve a -&gt; Rep (Resolve a) x)
-&gt; (forall x. Rep (Resolve a) x -&gt; Resolve a)
-&gt; Generic (Resolve a)
forall x. Rep (Resolve a) x -&gt; Resolve a
forall x. Resolve a -&gt; Rep (Resolve a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a x. Rep (Resolve a) x -&gt; Resolve a
forall a x. Resolve a -&gt; Rep (Resolve a) x
$cfrom :: forall a x. Resolve a -&gt; Rep (Resolve a) x
from :: forall x. Resolve a -&gt; Rep (Resolve a) x
$cto :: forall a x. Rep (Resolve a) x -&gt; Resolve a
to :: forall x. Rep (Resolve a) x -&gt; Resolve a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371679"><span id="local-6989586621680371684"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; Resolve a -&gt; Resolve b)
-&gt; (forall a b. a -&gt; Resolve b -&gt; Resolve a) -&gt; Functor Resolve
forall a b. a -&gt; Resolve b -&gt; Resolve a
forall a b. (a -&gt; b) -&gt; Resolve a -&gt; Resolve b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; Resolve a -&gt; Resolve b
fmap :: forall a b. (a -&gt; b) -&gt; Resolve a -&gt; Resolve b
$c&lt;$ :: forall a b. a -&gt; Resolve b -&gt; Resolve a
&lt;$ :: forall a b. a -&gt; Resolve b -&gt; Resolve a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371695"><span id="local-6989586621680371702"><span class="annot"><span class="annottext">Eq (Resolve a)
Eq (Resolve a) =&gt;
(Int -&gt; Resolve a -&gt; Int)
-&gt; (Resolve a -&gt; Int) -&gt; Hashable (Resolve a)
Int -&gt; Resolve a -&gt; Int
Resolve a -&gt; Int
forall a. Eq a =&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
forall a. Hashable a =&gt; Eq (Resolve a)
forall a. Hashable a =&gt; Int -&gt; Resolve a -&gt; Int
forall a. Hashable a =&gt; Resolve a -&gt; Int
$chashWithSalt :: forall a. Hashable a =&gt; Int -&gt; Resolve a -&gt; Int
hashWithSalt :: Int -&gt; Resolve a -&gt; Int
$chash :: forall a. Hashable a =&gt; Resolve a -&gt; Int
hash :: Resolve a -&gt; Int
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371727"><span id="local-6989586621680371734"><span id="local-6989586621680371739"><span id="local-6989586621680371741"><span id="local-6989586621680371743"><span id="local-6989586621680371749"><span id="local-6989586621680371755"><span id="local-6989586621680371758"><span id="local-6989586621680371761"><span id="local-6989586621680371764"><span id="local-6989586621680371767"><span id="local-6989586621680371770"><span id="local-6989586621680371775"><span id="local-6989586621680371780"><span class="annot"><span class="annottext">Typeable (Resolve a)
Typeable (Resolve a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Resolve a -&gt; c (Resolve a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Resolve a))
-&gt; (Resolve a -&gt; Constr)
-&gt; (Resolve a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Resolve a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Resolve a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Resolve a -&gt; Resolve a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a))
-&gt; Data (Resolve a)
Resolve a -&gt; Constr
Resolve a -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Resolve a -&gt; Resolve a
forall a. Data a =&gt; Typeable (Resolve a)
forall a. Data a =&gt; Resolve a -&gt; Constr
forall a. Data a =&gt; Resolve a -&gt; DataType
forall a.
Data a =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Resolve a -&gt; Resolve a
forall a u.
Data a =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; u
forall a u.
Data a =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; [u]
forall a r r'.
Data a =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
forall a r r'.
Data a =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
forall a (m :: * -&gt; *).
(Data a, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
forall a (c :: * -&gt; *).
Data a =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Resolve a)
forall a (c :: * -&gt; *).
Data a =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Resolve a -&gt; c (Resolve a)
forall a (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Resolve a))
forall a (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Resolve a))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Resolve a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Resolve a -&gt; c (Resolve a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Resolve a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Resolve a))
$cgfoldl :: forall a (c :: * -&gt; *).
Data a =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Resolve a -&gt; c (Resolve a)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Resolve a -&gt; c (Resolve a)
$cgunfold :: forall a (c :: * -&gt; *).
Data a =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Resolve a)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Resolve a)
$ctoConstr :: forall a. Data a =&gt; Resolve a -&gt; Constr
toConstr :: Resolve a -&gt; Constr
$cdataTypeOf :: forall a. Data a =&gt; Resolve a -&gt; DataType
dataTypeOf :: Resolve a -&gt; DataType
$cdataCast1 :: forall a (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Resolve a))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Resolve a))
$cdataCast2 :: forall a (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Resolve a))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Resolve a))
$cgmapT :: forall a.
Data a =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Resolve a -&gt; Resolve a
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Resolve a -&gt; Resolve a
$cgmapQl :: forall a r r'.
Data a =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
$cgmapQr :: forall a r r'.
Data a =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Resolve a -&gt; r
$cgmapQ :: forall a u.
Data a =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; [u]
$cgmapQi :: forall a u.
Data a =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Resolve a -&gt; u
$cgmapM :: forall a (m :: * -&gt; *).
(Data a, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
$cgmapMp :: forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
$cgmapMo :: forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Resolve a -&gt; m (Resolve a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span class="annot"><span class="hs-comment">-- | lens for 'Resolve' position</span></span><span>
</span><span id="line-72"></span><span id="local-6989586621680371369"><span class="annot"><a href="M.Collision.Effectful.html#_respos"><span class="hs-identifier hs-type">_respos</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lens'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371369"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371369"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-73"></span><span id="_respos"><span class="annot"><span class="annottext">_respos :: forall a (f :: * -&gt; *).
Functor f =&gt;
(V3 a -&gt; f (V3 a)) -&gt; Resolve a -&gt; f (Resolve a)
</span><a href="M.Collision.Effectful.html#_respos"><span class="hs-identifier hs-var hs-var">_respos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Resolve a -&gt; V3 a)
-&gt; (Resolve a -&gt; V3 a -&gt; Resolve a)
-&gt; Lens (Resolve a) (Resolve a) (V3 a) (V3 a)
forall s a b t. (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
</span><span class="hs-identifier hs-var">lens</span></span><span> </span><span class="annot"><span class="annottext">Resolve a -&gt; V3 a
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var">respos</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680371794"><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371794"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621680371795"><span class="annot"><span class="annottext">V3 a
</span><a href="#local-6989586621680371795"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371794"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var">respos</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680371795"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-74"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#_respos"><span class="hs-pragma hs-type">_respos</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="annot"><span class="hs-comment">-- | lens for 'Resolve' displacement</span></span><span>
</span><span id="line-77"></span><span id="local-6989586621680371796"><span class="annot"><a href="M.Collision.Effectful.html#_resdis"><span class="hs-identifier hs-type">_resdis</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lens'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371796"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371796"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-78"></span><span id="_resdis"><span class="annot"><span class="annottext">_resdis :: forall a (f :: * -&gt; *).
Functor f =&gt;
(V3 a -&gt; f (V3 a)) -&gt; Resolve a -&gt; f (Resolve a)
</span><a href="M.Collision.Effectful.html#_resdis"><span class="hs-identifier hs-var hs-var">_resdis</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Resolve a -&gt; V3 a)
-&gt; (Resolve a -&gt; V3 a -&gt; Resolve a)
-&gt; Lens (Resolve a) (Resolve a) (V3 a) (V3 a)
forall s a b t. (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
</span><span class="hs-identifier hs-var">lens</span></span><span> </span><span class="annot"><span class="annottext">Resolve a -&gt; V3 a
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680371799"><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371799"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621680371800"><span class="annot"><span class="annottext">V3 a
</span><a href="#local-6989586621680371800"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371799"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680371800"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-79"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#_resdis"><span class="hs-pragma hs-type">_resdis</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="annot"><span class="hs-comment">-- | lens for 'Resolve' newly touching ground</span></span><span>
</span><span id="line-82"></span><span id="local-6989586621680371379"><span class="annot"><a href="M.Collision.Effectful.html#_restou"><span class="hs-identifier hs-type">_restou</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lens'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371379"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-type">NewlyTouchingGround</span></a></span></span><span>
</span><span id="line-83"></span><span id="_restou"><span class="annot"><span class="annottext">_restou :: forall a (f :: * -&gt; *).
Functor f =&gt;
(NewlyTouchingGround -&gt; f NewlyTouchingGround)
-&gt; Resolve a -&gt; f (Resolve a)
</span><a href="M.Collision.Effectful.html#_restou"><span class="hs-identifier hs-var hs-var">_restou</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Resolve a -&gt; NewlyTouchingGround)
-&gt; (Resolve a -&gt; NewlyTouchingGround -&gt; Resolve a)
-&gt; Lens
     (Resolve a) (Resolve a) NewlyTouchingGround NewlyTouchingGround
forall s a b t. (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
</span><span class="hs-identifier hs-var">lens</span></span><span> </span><span class="annot"><span class="annottext">Resolve a -&gt; NewlyTouchingGround
forall a. Resolve a -&gt; NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var">restou</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680371803"><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371803"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621680371804"><span class="annot"><span class="annottext">NewlyTouchingGround
</span><a href="#local-6989586621680371804"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Resolve a
</span><a href="#local-6989586621680371803"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var">restou</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680371804"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-84"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#_restou"><span class="hs-pragma hs-type">_restou</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-comment">-- | \'upgrade\' a boolean: find @y@ as in @y CMP x || y == x@</span><span>
</span><span id="line-87"></span><span class="hs-comment">-- but if @CMP@ is not 'EQ', prefer @y /= x@</span><span>
</span><span id="line-88"></span><span class="hs-comment">--</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- used to implement 'updonground'</span><span>
</span><span id="line-90"></span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-type">boolupgr</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><span class="hs-comment">-- | comparison (@CMP@)</span></span><span>
</span><span id="line-92"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Ordering</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-93"></span><span>  </span><span class="annot"><span class="hs-comment">-- | the @x@</span></span><span>
</span><span id="line-94"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-95"></span><span>  </span><span class="annot"><span class="hs-comment">-- | left-hand side of the @CMP@ comparison</span></span><span>
</span><span id="line-96"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-97"></span><span id="boolupgr"><span class="annot"><span class="annottext">boolupgr :: Ordering -&gt; Bool -&gt; Bool
</span><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var hs-var">boolupgr</span></a></span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-98"></span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var">boolupgr</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-99"></span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var">boolupgr</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span> </span><span id="local-6989586621680371806"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680371806"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680371806"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-100"></span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var">boolupgr</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-101"></span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var">boolupgr</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-102"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-pragma hs-type">boolupgr</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="annot"><span class="hs-comment">-- | \'update\' the on-ground status</span></span><span>
</span><span id="line-105"></span><span class="annot"><a href="M.Collision.Effectful.html#updonground"><span class="hs-identifier hs-type">updonground</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-type">NewlyTouchingGround</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-106"></span><span id="updonground"><span class="annot"><span class="annottext">updonground :: NewlyTouchingGround -&gt; Bool -&gt; Bool
</span><a href="M.Collision.Effectful.html#updonground"><span class="hs-identifier hs-var hs-var">updonground</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Ordering -&gt; Bool -&gt; Bool) -&gt; NewlyTouchingGround -&gt; Bool -&gt; Bool
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; Bool -&gt; Bool
</span><a href="M.Collision.Effectful.html#boolupgr"><span class="hs-identifier hs-var">boolupgr</span></a></span><span>
</span><span id="line-107"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#updonground"><span class="hs-pragma hs-type">updonground</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="hs-comment">-- internal control-flow exception because i don't think i can use call/cc</span><span>
</span><span id="line-110"></span><span class="hs-keyword">newtype</span><span> </span><span id="EarlyExit"><span class="annot"><a href="M.Collision.Effectful.html#EarlyExit"><span class="hs-identifier hs-var">EarlyExit</span></a></span></span><span> </span><span id="local-6989586621680371517"><span class="annot"><a href="#local-6989586621680371517"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="EarlyExit"><span class="annot"><a href="M.Collision.Effectful.html#EarlyExit"><span class="hs-identifier hs-var">EarlyExit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371517"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680371809"><span id="local-6989586621680371811"><span class="annot"><span class="annottext">(forall x. EarlyExit a -&gt; Rep (EarlyExit a) x)
-&gt; (forall x. Rep (EarlyExit a) x -&gt; EarlyExit a)
-&gt; Generic (EarlyExit a)
forall x. Rep (EarlyExit a) x -&gt; EarlyExit a
forall x. EarlyExit a -&gt; Rep (EarlyExit a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a x. Rep (EarlyExit a) x -&gt; EarlyExit a
forall a x. EarlyExit a -&gt; Rep (EarlyExit a) x
$cfrom :: forall a x. EarlyExit a -&gt; Rep (EarlyExit a) x
from :: forall x. EarlyExit a -&gt; Rep (EarlyExit a) x
$cto :: forall a x. Rep (EarlyExit a) x -&gt; EarlyExit a
to :: forall x. Rep (EarlyExit a) x -&gt; EarlyExit a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">)</span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">anyclass</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680371821"><span id="local-6989586621680371825"><span id="local-6989586621680371828"><span id="local-6989586621680371831"><span class="annot"><span class="annottext">Show (EarlyExit a)
Typeable (EarlyExit a)
(Typeable (EarlyExit a), Show (EarlyExit a)) =&gt;
(EarlyExit a -&gt; SomeException)
-&gt; (SomeException -&gt; Maybe (EarlyExit a))
-&gt; (EarlyExit a -&gt; String)
-&gt; (EarlyExit a -&gt; Bool)
-&gt; Exception (EarlyExit a)
SomeException -&gt; Maybe (EarlyExit a)
EarlyExit a -&gt; Bool
EarlyExit a -&gt; String
EarlyExit a -&gt; SomeException
forall a. Typeable a =&gt; Show (EarlyExit a)
forall a. Typeable a =&gt; Typeable (EarlyExit a)
forall e.
(Typeable e, Show e) =&gt;
(e -&gt; SomeException)
-&gt; (SomeException -&gt; Maybe e)
-&gt; (e -&gt; String)
-&gt; (e -&gt; Bool)
-&gt; Exception e
forall a. Typeable a =&gt; SomeException -&gt; Maybe (EarlyExit a)
forall a. Typeable a =&gt; EarlyExit a -&gt; Bool
forall a. Typeable a =&gt; EarlyExit a -&gt; String
forall a. Typeable a =&gt; EarlyExit a -&gt; SomeException
$ctoException :: forall a. Typeable a =&gt; EarlyExit a -&gt; SomeException
toException :: EarlyExit a -&gt; SomeException
$cfromException :: forall a. Typeable a =&gt; SomeException -&gt; Maybe (EarlyExit a)
fromException :: SomeException -&gt; Maybe (EarlyExit a)
$cdisplayException :: forall a. Typeable a =&gt; EarlyExit a -&gt; String
displayException :: EarlyExit a -&gt; String
$cbacktraceDesired :: forall a. Typeable a =&gt; EarlyExit a -&gt; Bool
backtraceDesired :: EarlyExit a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Exception</span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680371389"><span id="local-6989586621680371835"><span id="local-6989586621680371839"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#EarlyExit"><span class="hs-identifier hs-type">EarlyExit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371389"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>  </span><span id="local-6989586621680371841"><span class="annot"><span class="annottext">show :: EarlyExit a -&gt; String
</span><a href="#local-6989586621680371841"><span class="hs-identifier hs-var hs-var hs-var">show</span></a></span></span><span> </span><span class="annot"><span class="annottext">EarlyExit a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;EarlyExit&quot;</span></span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="hs-comment">-- | newly touching ground?</span><span>
</span><span id="line-118"></span><span class="hs-comment">--</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- - 'LT' means it taking off from the ground</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- - 'EQ' means it should maintain the previous state</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- - 'GT' means it landing on the ground</span><span>
</span><span id="line-122"></span><span class="hs-keyword">newtype</span><span> </span><span id="NewlyTouchingGround"><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-var">NewlyTouchingGround</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NewlyTouchingGround"><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-var">NewlyTouchingGround</span></a></span></span><span> </span><span class="hs-special">{</span><span id="newonground"><span class="annot"><span class="annottext">NewlyTouchingGround -&gt; Ordering
</span><a href="M.Collision.Effectful.html#newonground"><span class="hs-identifier hs-var hs-var">newonground</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ordering</span></span><span class="hs-special">}</span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">newtype</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680371845"><span id="local-6989586621680371850"><span id="local-6989586621680371854"><span class="annot"><span class="annottext">Int -&gt; NewlyTouchingGround -&gt; String -&gt; String
[NewlyTouchingGround] -&gt; String -&gt; String
NewlyTouchingGround -&gt; String
(Int -&gt; NewlyTouchingGround -&gt; String -&gt; String)
-&gt; (NewlyTouchingGround -&gt; String)
-&gt; ([NewlyTouchingGround] -&gt; String -&gt; String)
-&gt; Show NewlyTouchingGround
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
$cshowsPrec :: Int -&gt; NewlyTouchingGround -&gt; String -&gt; String
showsPrec :: Int -&gt; NewlyTouchingGround -&gt; String -&gt; String
$cshow :: NewlyTouchingGround -&gt; String
show :: NewlyTouchingGround -&gt; String
$cshowList :: [NewlyTouchingGround] -&gt; String -&gt; String
showList :: [NewlyTouchingGround] -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371859"><span id="local-6989586621680371863"><span class="annot"><span class="annottext">NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
(NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; Eq NewlyTouchingGround
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
== :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
$c/= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
/= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371870"><span id="local-6989586621680371875"><span id="local-6989586621680371879"><span id="local-6989586621680371883"><span id="local-6989586621680371887"><span id="local-6989586621680371891"><span id="local-6989586621680371895"><span class="annot"><span class="annottext">Eq NewlyTouchingGround
Eq NewlyTouchingGround =&gt;
(NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Ordering)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool)
-&gt; (NewlyTouchingGround
    -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround)
-&gt; (NewlyTouchingGround
    -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround)
-&gt; Ord NewlyTouchingGround
NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Ordering
NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Ordering
compare :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Ordering
$c&lt; :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
&lt; :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
$c&lt;= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
&lt;= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
$c&gt; :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
&gt; :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
$c&gt;= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
&gt;= :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; Bool
$cmax :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
max :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
$cmin :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
min :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371907"><span id="local-6989586621680371912"><span id="local-6989586621680371916"><span id="local-6989586621680371920"><span id="local-6989586621680371924"><span id="local-6989586621680371928"><span id="local-6989586621680371932"><span id="local-6989586621680371936"><span class="annot"><span class="annottext">Int -&gt; NewlyTouchingGround
NewlyTouchingGround -&gt; Int
NewlyTouchingGround -&gt; [NewlyTouchingGround]
NewlyTouchingGround -&gt; NewlyTouchingGround
NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround]
NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; [NewlyTouchingGround]
(NewlyTouchingGround -&gt; NewlyTouchingGround)
-&gt; (NewlyTouchingGround -&gt; NewlyTouchingGround)
-&gt; (Int -&gt; NewlyTouchingGround)
-&gt; (NewlyTouchingGround -&gt; Int)
-&gt; (NewlyTouchingGround -&gt; [NewlyTouchingGround])
-&gt; (NewlyTouchingGround
    -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround])
-&gt; (NewlyTouchingGround
    -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround])
-&gt; (NewlyTouchingGround
    -&gt; NewlyTouchingGround
    -&gt; NewlyTouchingGround
    -&gt; [NewlyTouchingGround])
-&gt; Enum NewlyTouchingGround
forall a.
(a -&gt; a)
-&gt; (a -&gt; a)
-&gt; (Int -&gt; a)
-&gt; (a -&gt; Int)
-&gt; (a -&gt; [a])
-&gt; (a -&gt; a -&gt; [a])
-&gt; (a -&gt; a -&gt; [a])
-&gt; (a -&gt; a -&gt; a -&gt; [a])
-&gt; Enum a
$csucc :: NewlyTouchingGround -&gt; NewlyTouchingGround
succ :: NewlyTouchingGround -&gt; NewlyTouchingGround
$cpred :: NewlyTouchingGround -&gt; NewlyTouchingGround
pred :: NewlyTouchingGround -&gt; NewlyTouchingGround
$ctoEnum :: Int -&gt; NewlyTouchingGround
toEnum :: Int -&gt; NewlyTouchingGround
$cfromEnum :: NewlyTouchingGround -&gt; Int
fromEnum :: NewlyTouchingGround -&gt; Int
$cenumFrom :: NewlyTouchingGround -&gt; [NewlyTouchingGround]
enumFrom :: NewlyTouchingGround -&gt; [NewlyTouchingGround]
$cenumFromThen :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround]
enumFromThen :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround]
$cenumFromTo :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround]
enumFromTo :: NewlyTouchingGround -&gt; NewlyTouchingGround -&gt; [NewlyTouchingGround]
$cenumFromThenTo :: NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; [NewlyTouchingGround]
enumFromThenTo :: NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; NewlyTouchingGround
-&gt; [NewlyTouchingGround]
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Enum</span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371946"><span id="local-6989586621680371951"><span class="annot"><span class="annottext">NewlyTouchingGround
NewlyTouchingGround
-&gt; NewlyTouchingGround -&gt; Bounded NewlyTouchingGround
forall a. a -&gt; a -&gt; Bounded a
$cminBound :: NewlyTouchingGround
minBound :: NewlyTouchingGround
$cmaxBound :: NewlyTouchingGround
maxBound :: NewlyTouchingGround
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Bounded</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680371961"><span id="local-6989586621680371966"><span class="annot"><span class="annottext">Eq NewlyTouchingGround
Eq NewlyTouchingGround =&gt;
(Int -&gt; NewlyTouchingGround -&gt; Int)
-&gt; (NewlyTouchingGround -&gt; Int) -&gt; Hashable NewlyTouchingGround
Int -&gt; NewlyTouchingGround -&gt; Int
NewlyTouchingGround -&gt; Int
forall a. Eq a =&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
$chashWithSalt :: Int -&gt; NewlyTouchingGround -&gt; Int
hashWithSalt :: Int -&gt; NewlyTouchingGround -&gt; Int
$chash :: NewlyTouchingGround -&gt; Int
hash :: NewlyTouchingGround -&gt; Int
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680371974"><span id="local-6989586621680371978"><span id="local-6989586621680371981"><span id="local-6989586621680371983"><span id="local-6989586621680371985"><span id="local-6989586621680371990"><span id="local-6989586621680371995"><span id="local-6989586621680371998"><span id="local-6989586621680372001"><span id="local-6989586621680372004"><span id="local-6989586621680372007"><span id="local-6989586621680372010"><span id="local-6989586621680372015"><span id="local-6989586621680372020"><span class="annot"><span class="annottext">Typeable NewlyTouchingGround
Typeable NewlyTouchingGround =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; NewlyTouchingGround
 -&gt; c NewlyTouchingGround)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewlyTouchingGround)
-&gt; (NewlyTouchingGround -&gt; Constr)
-&gt; (NewlyTouchingGround -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewlyTouchingGround))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c NewlyTouchingGround))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; NewlyTouchingGround -&gt; NewlyTouchingGround)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround)
-&gt; Data NewlyTouchingGround
NewlyTouchingGround -&gt; Constr
NewlyTouchingGround -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewlyTouchingGround
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NewlyTouchingGround
-&gt; c NewlyTouchingGround
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewlyTouchingGround)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NewlyTouchingGround)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NewlyTouchingGround
-&gt; c NewlyTouchingGround
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NewlyTouchingGround
-&gt; c NewlyTouchingGround
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewlyTouchingGround
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewlyTouchingGround
$ctoConstr :: NewlyTouchingGround -&gt; Constr
toConstr :: NewlyTouchingGround -&gt; Constr
$cdataTypeOf :: NewlyTouchingGround -&gt; DataType
dataTypeOf :: NewlyTouchingGround -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewlyTouchingGround)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewlyTouchingGround)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NewlyTouchingGround)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NewlyTouchingGround)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; NewlyTouchingGround -&gt; NewlyTouchingGround
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewlyTouchingGround -&gt; r
$cgmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewlyTouchingGround -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NewlyTouchingGround -&gt; m NewlyTouchingGround
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680372025"><span id="local-6989586621680372027"><span class="annot"><span class="annottext">(forall x. NewlyTouchingGround -&gt; Rep NewlyTouchingGround x)
-&gt; (forall x. Rep NewlyTouchingGround x -&gt; NewlyTouchingGround)
-&gt; Generic NewlyTouchingGround
forall x. Rep NewlyTouchingGround x -&gt; NewlyTouchingGround
forall x. NewlyTouchingGround -&gt; Rep NewlyTouchingGround x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NewlyTouchingGround -&gt; Rep NewlyTouchingGround x
from :: forall x. NewlyTouchingGround -&gt; Rep NewlyTouchingGround x
$cto :: forall x. Rep NewlyTouchingGround x -&gt; NewlyTouchingGround
to :: forall x. Rep NewlyTouchingGround x -&gt; NewlyTouchingGround
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="annot"><span class="hs-comment">-- | is it landing?</span></span><span>
</span><span id="line-127"></span><span class="annot"><a href="M.Collision.Effectful.html#islanding"><span class="hs-identifier hs-type">islanding</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-type">NewlyTouchingGround</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-128"></span><span id="islanding"><span class="annot"><span class="annottext">islanding :: NewlyTouchingGround -&gt; Bool
</span><a href="M.Collision.Effectful.html#islanding"><span class="hs-identifier hs-var hs-var">islanding</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ordering -&gt; Ordering -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Ordering -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; Ordering) -&gt; NewlyTouchingGround -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NewlyTouchingGround -&gt; Ordering
</span><a href="M.Collision.Effectful.html#newonground"><span class="hs-identifier hs-var">newonground</span></a></span><span>
</span><span id="line-129"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#islanding"><span class="hs-pragma hs-type">islanding</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="annot"><span class="hs-comment">-- | is it taking off?</span></span><span>
</span><span id="line-132"></span><span class="annot"><a href="M.Collision.Effectful.html#istakingoff"><span class="hs-identifier hs-type">istakingoff</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-type">NewlyTouchingGround</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-133"></span><span id="istakingoff"><span class="annot"><span class="annottext">istakingoff :: NewlyTouchingGround -&gt; Bool
</span><a href="M.Collision.Effectful.html#istakingoff"><span class="hs-identifier hs-var hs-var">istakingoff</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ordering -&gt; Ordering -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Ordering -&gt; Bool)
-&gt; (NewlyTouchingGround -&gt; Ordering) -&gt; NewlyTouchingGround -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NewlyTouchingGround -&gt; Ordering
</span><a href="M.Collision.Effectful.html#newonground"><span class="hs-identifier hs-var">newonground</span></a></span><span>
</span><span id="line-134"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#istakingoff"><span class="hs-pragma hs-type">istakingoff</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="annot"><span class="hs-comment">-- | get a block's shape at integer coordinates (dynamic effect)</span></span><span>
</span><span id="line-137"></span><span class="hs-keyword">data</span><span> </span><span id="GetBlock"><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-var">GetBlock</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680372030"><span class="annot"><a href="#local-6989586621680372030"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680372031"><span class="annot"><a href="#local-6989586621680372031"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Effect</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-138"></span><span>  </span><span class="annot"><span class="hs-comment">-- | get a block's shape at integer coordinates</span></span><span>
</span><span id="line-139"></span><span>  </span><span id="local-6989586621680371420"><span id="local-6989586621680371421"><span id="local-6989586621680371422"><span id="GetBlock"><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-var">GetBlock</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">%</span><span class="hs-number">1</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371420"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371421"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371422"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680371420"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371421"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="DispatchOf"><span class="annot"><span class="hs-identifier hs-var">DispatchOf</span></span></span><span> </span><span id="local-6989586621680372032"><span id="local-6989586621680372033"><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372032"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372033"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dynamic</span></span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="annot"><span class="hs-comment">-- | get a block's shape at integer coordinates</span></span><span>
</span><span id="line-144"></span><span id="local-6989586621680371405"><span id="local-6989586621680371406"><span id="local-6989586621680371408"><span class="annot"><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier hs-type">getblock</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371405"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371406"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371408"><span class="hs-identifier hs-type">ef</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-146"></span><span>  </span><span class="annot"><span class="hs-comment">-- | integer coordinates</span></span><span>
</span><span id="line-147"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-comment">-- | if (relevant) block exists, return its shape</span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-comment">-- what block is \&quot;relevant\&quot; is up to the implementation</span><span>
</span><span id="line-151"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371408"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680371405"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371406"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-152"></span><span id="getblock"><span class="annot"><span class="annottext">getblock :: forall (f :: * -&gt; *) a (ef :: [Effect]).
(HasCallStack, GetBlock f a :&gt; ef) =&gt;
V3 Int -&gt; Eff ef (Maybe (f a))
</span><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier hs-var hs-var">getblock</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GetBlock f a (Eff ef) (Maybe (f a)) -&gt; Eff ef (Maybe (f a))
forall (e :: Effect) (es :: [Effect]) a.
(HasCallStack, DispatchOf e ~ 'Dynamic, e :&gt; es) =&gt;
e (Eff es) a -&gt; Eff es a
</span><span class="hs-identifier hs-var">send</span></span><span> </span><span class="annot"><span class="annottext">(GetBlock f a (Eff ef) (Maybe (f a)) -&gt; Eff ef (Maybe (f a)))
-&gt; (V3 Int -&gt; GetBlock f a (Eff ef) (Maybe (f a)))
-&gt; V3 Int
-&gt; Eff ef (Maybe (f a))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">V3 Int -&gt; GetBlock f a (Eff ef) (Maybe (f a))
forall (f :: * -&gt; *) a (m :: * -&gt; *).
V3 Int -&gt; GetBlock f a m (Maybe (f a))
</span><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-var">GetBlock</span></a></span><span>
</span><span id="line-153"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#getblock"><span class="hs-pragma hs-type">getblock</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="annot"><span class="hs-comment">-- | detect and resolve collision</span></span><span>
</span><span id="line-156"></span><span id="local-6989586621680371423"><span id="local-6989586621680371425"><span id="local-6989586621680371427"><span class="annot"><a href="M.Collision.Effectful.html#resolve"><span class="hs-identifier hs-type">resolve</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-157"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Shape"><span class="hs-identifier hs-type">Shape</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371423"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-158"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">RealFloat</span></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-159"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Epsilon</span></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-160"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-161"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371423"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371427"><span class="hs-identifier hs-type">ef</span></a></span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-163"></span><span>  </span><span class="annot"><span class="hs-comment">-- | shape of the object who is moving</span></span><span>
</span><span id="line-164"></span><span>  </span><span class="annot"><a href="#local-6989586621680371423"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-165"></span><span>  </span><span class="annot"><span class="hs-comment">-- | attempted displacement</span></span><span>
</span><span id="line-166"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-167"></span><span>  </span><span class="hs-comment">-- | new resolution</span><span>
</span><span id="line-168"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span>  </span><span class="hs-comment">-- unless it got stuck, the new displacement should be zero</span><span>
</span><span id="line-170"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371427"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-171"></span><span id="resolve"><span class="annot"><span class="annottext">resolve :: forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, RealFloat n, Epsilon n, Typeable n,
 GetBlock s n :&gt; ef) =&gt;
s n -&gt; V3 n -&gt; Eff ef (Resolve n)
</span><a href="M.Collision.Effectful.html#resolve"><span class="hs-identifier hs-var hs-var">resolve</span></a></span></span><span> </span><span id="local-6989586621680372097"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372097"><span class="hs-identifier hs-var">myself</span></a></span></span><span> </span><span id="local-6989586621680372098"><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372098"><span class="hs-identifier hs-var">disp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-172"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680372099"><span class="annot"><span class="annottext">res0 :: Resolve n
</span><a href="#local-6989586621680372099"><span class="hs-identifier hs-var hs-var">res0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; NewlyTouchingGround -&gt; Resolve n
forall a. V3 a -&gt; V3 a -&gt; NewlyTouchingGround -&gt; Resolve a
</span><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-var">Resolve</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">s n -&gt; V3 n
forall a. (Fractional a, Ord a) =&gt; s a -&gt; V3 a
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; V3 a
</span><a href="M.Collision.Pure.html#scenter"><span class="hs-identifier hs-var">scenter</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372097"><span class="hs-identifier hs-var">myself</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372098"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ordering -&gt; NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#NewlyTouchingGround"><span class="hs-identifier hs-var">NewlyTouchingGround</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>      </span><span id="local-6989586621680372101"><span class="annot"><span class="annottext">fps :: [V3 n]
</span><a href="#local-6989586621680372101"><span class="hs-identifier hs-var hs-var">fps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-174"></span><span>        </span><span class="annot"><span class="annottext">(V3 Int -&gt; V3 n) -&gt; [V3 Int] -&gt; [V3 n]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">s n -&gt; V3 n
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; V3 a
</span><a href="M.Collision.Pure.html#slocorner"><span class="hs-identifier hs-var">slocorner</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372097"><span class="hs-identifier hs-var">myself</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; V3 n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(V3 n -&gt; V3 n) -&gt; (V3 Int -&gt; V3 n) -&gt; V3 Int -&gt; V3 n
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; n) -&gt; V3 Int -&gt; V3 n
forall a b. (a -&gt; b) -&gt; V3 a -&gt; V3 b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; n
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-175"></span><span>          </span><span class="annot"><span class="annottext">V3 Int -&gt; V3 Int -&gt; [V3 Int]
</span><a href="M.Collision.Internal.Face.html#facepoints"><span class="hs-identifier hs-var">facepoints</span></a></span><span>
</span><span id="line-176"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n -&gt; Int
forall b. Integral b =&gt; n -&gt; b
forall a b. (RealFrac a, Integral b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">ceiling</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Int) -&gt; V3 n -&gt; V3 Int
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">s n -&gt; V3 n
forall a. (Fractional a, Ord a) =&gt; s a -&gt; V3 a
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; V3 a
</span><a href="M.Collision.Pure.html#sdimensions"><span class="hs-identifier hs-var">sdimensions</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372097"><span class="hs-identifier hs-var">myself</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n -&gt; Int
forall b. Integral b =&gt; n -&gt; b
forall a b. (RealFrac a, Integral b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">round</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Int) -&gt; (n -&gt; n) -&gt; n -&gt; Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n
forall a. Num a =&gt; a -&gt; a
</span><span class="hs-identifier hs-var">signum</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Int) -&gt; V3 n -&gt; V3 Int
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372098"><span class="hs-identifier hs-var">disp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-178"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Eff ef (Resolve n)
-&gt; (EarlyExit n -&gt; Eff ef (Resolve n)) -&gt; Eff ef (Resolve n)
forall e (es :: [Effect]) a.
Exception e =&gt;
Eff es a -&gt; (e -&gt; Eff es a) -&gt; Eff es a
</span><span class="hs-identifier hs-var">catch</span></span><span>
</span><span id="line-179"></span><span>        </span><span class="hs-keyword">do</span><span>
</span><span id="line-180"></span><span>          </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Bool
forall a. Epsilon a =&gt; a -&gt; Bool
</span><span class="hs-identifier hs-var">nearZero</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372098"><span class="hs-identifier hs-var">disp</span></a></span><span>
</span><span id="line-181"></span><span>            </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; Eff ef (Resolve n)
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372099"><span class="hs-identifier hs-var">res0</span></a></span><span>
</span><span id="line-182"></span><span>            </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">[V3 n]
-&gt; Eff (Reader [V3 n] : ef) (Resolve n) -&gt; Eff ef (Resolve n)
forall r (es :: [Effect]) a.
HasCallStack =&gt;
r -&gt; Eff (Reader r : es) a -&gt; Eff es a
</span><span class="hs-identifier hs-var">runReader</span></span><span> </span><span class="annot"><span class="annottext">[V3 n]
</span><a href="#local-6989586621680372101"><span class="hs-identifier hs-var">fps</span></a></span><span> </span><span class="annot"><span class="annottext">(Eff (Reader [V3 n] : ef) (Resolve n) -&gt; Eff ef (Resolve n))
-&gt; (Resolve n -&gt; Eff (Reader [V3 n] : ef) (Resolve n))
-&gt; Resolve n
-&gt; Eff ef (Resolve n)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">s n -&gt; Resolve n -&gt; Eff (Reader [V3 n] : ef) (Resolve n)
forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, RealFloat n, Epsilon n, Typeable n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
s n -&gt; Resolve n -&gt; Eff ef (Resolve n)
</span><a href="M.Collision.Effectful.html#resolve%27"><span class="hs-identifier hs-var">resolve'</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372097"><span class="hs-identifier hs-var">myself</span></a></span><span> </span><span class="annot"><span class="annottext">(Resolve n -&gt; Eff ef (Resolve n))
-&gt; Resolve n -&gt; Eff ef (Resolve n)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372099"><span class="hs-identifier hs-var">res0</span></a></span><span>
</span><span id="line-183"></span><span>        </span><span class="hs-keyword">do</span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#EarlyExit"><span class="hs-identifier hs-type">EarlyExit</span></a></span><span> </span><span id="local-6989586621680372114"><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372114"><span class="hs-identifier hs-var">res1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; Eff ef (Resolve n)
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372114"><span class="hs-identifier hs-var">res1</span></a></span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- the actual implementation of 'resolve'</span><span>
</span><span id="line-186"></span><span class="annot"><a href="M.Collision.Effectful.html#resolve%27"><span class="hs-identifier hs-type">resolve'</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-187"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621680371463"><span class="annot"><a href="#local-6989586621680371463"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621680371464"><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621680371465"><span class="annot"><a href="#local-6989586621680371465"><span class="hs-identifier hs-type">ef</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Shape"><span class="hs-identifier hs-type">Shape</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371463"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-189"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">RealFloat</span></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-190"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Epsilon</span></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-191"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-192"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371463"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371465"><span class="hs-identifier hs-type">ef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">-- face points</span><span>
</span><span id="line-194"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Reader</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371465"><span class="hs-identifier hs-type">ef</span></a></span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-196"></span><span>  </span><span class="annot"><a href="#local-6989586621680371463"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-197"></span><span>  </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-198"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371465"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span id="resolve%27"><span class="annot"><span class="annottext">resolve' :: forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, RealFloat n, Epsilon n, Typeable n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
s n -&gt; Resolve n -&gt; Eff ef (Resolve n)
</span><a href="M.Collision.Effectful.html#resolve%27"><span class="hs-identifier hs-var hs-var">resolve'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-200"></span><span>  </span><span class="hs-comment">-- this is a loop that will run until the displacement is resolved</span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-comment">-- (i.e., until it stops moving due to resolution or being blocked)</span><span>
</span><span id="line-202"></span><span>  </span><span class="annot"><span class="annottext">((s n -&gt; Resolve n -&gt; Eff ef (Resolve n))
 -&gt; s n -&gt; Resolve n -&gt; Eff ef (Resolve n))
-&gt; s n -&gt; Resolve n -&gt; Eff ef (Resolve n)
forall a. (a -&gt; a) -&gt; a
</span><span class="hs-identifier hs-var">fix</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372238"><span class="annot"><span class="annottext">s n -&gt; Resolve n -&gt; Eff ef (Resolve n)
</span><a href="#local-6989586621680372238"><span class="hs-identifier hs-var">cont</span></a></span></span><span> </span><span id="local-6989586621680372239"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372239"><span class="hs-identifier hs-var">myself</span></a></span></span><span> </span><span id="local-6989586621680372240"><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372240"><span class="hs-identifier hs-var">resolution</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-comment">-- sample some points off the relevant faces of the object</span><span>
</span><span id="line-204"></span><span>    </span><span class="hs-comment">-- we will grid march along the rays (of the displacement) shot</span><span>
</span><span id="line-205"></span><span>    </span><span class="hs-comment">-- from these points</span><span>
</span><span id="line-206"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680372241"><span class="annot"><span class="annottext">disp :: V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var hs-var hs-var">disp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; V3 n
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372240"><span class="hs-identifier hs-var">resolution</span></a></span><span>
</span><span id="line-207"></span><span>        </span><span id="local-6989586621680372242"><span class="annot"><span class="annottext">gofast :: Bool
</span><a href="#local-6989586621680372242"><span class="hs-identifier hs-var hs-var hs-var">gofast</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-208"></span><span>          </span><span class="hs-comment">-- if the assumptions of the fast core algorithm are met,</span><span>
</span><span id="line-209"></span><span>          </span><span class="hs-comment">-- yeah, apply the fast core algorithm</span><span>
</span><span id="line-210"></span><span>          </span><span class="annot"><span class="annottext">V3 n -&gt; n
forall a. Num a =&gt; V3 a -&gt; a
forall (f :: * -&gt; *) a. (Metric f, Num a) =&gt; f a -&gt; a
</span><span class="hs-identifier hs-var">quadrance</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span>
</span><span id="line-211"></span><span>            </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">n -&gt; n
forall a. Num a =&gt; a -&gt; a
</span><span class="hs-identifier hs-var">abs</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R1 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_x</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span>
</span><span id="line-212"></span><span>                   </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n
forall a. Num a =&gt; a -&gt; a
</span><span class="hs-identifier hs-var">abs</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R3 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_z</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span>
</span><span id="line-213"></span><span>                   </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n
forall a. Num a =&gt; a -&gt; a
</span><span class="hs-identifier hs-var">abs</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span>
</span><span id="line-214"></span><span>               </span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>        </span><span id="local-6989586621680372251"><span class="annot"><span class="annottext">core :: Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372251"><span class="hs-identifier hs-var hs-var hs-var">core</span></a></span></span><span>
</span><span id="line-216"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680372242"><span class="hs-identifier hs-var">gofast</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, Epsilon n, RealFloat n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#fastcore"><span class="hs-identifier hs-var">fastcore</span></a></span><span>
</span><span id="line-217"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, Epsilon n, RealFloat n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#slowcore"><span class="hs-identifier hs-var">slowcore</span></a></span><span>
</span><span id="line-218"></span><span>    </span><span id="local-6989586621680372254"><span class="annot"><a href="#local-6989586621680372254"><span class="hs-identifier hs-var">fps</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall r (es :: [Effect]).
(HasCallStack, Reader r :&gt; es) =&gt;
Eff es r
</span><span class="hs-identifier hs-var">ask</span></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371464"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- retrieve the face points</span><span>
</span><span id="line-219"></span><span>    </span><span class="hs-comment">-- if i'm currently in contact with something, i can freely</span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-comment">-- move in the direction of the displacement, as part of the</span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-comment">-- game physics; this is so i can unstuck myself out</span><span>
</span><span id="line-222"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">fmap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">floor</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680372254"><span class="hs-identifier hs-type">fps</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-223"></span><span>      </span><span class="annot"><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier hs-type">getblock</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&gt;=&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-224"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680372259"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372259"><span class="hs-identifier hs-var">block</span></a></span></span><span>
</span><span id="line-225"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">s n -&gt; s n -&gt; Bool
forall a. (Fractional a, Ord a) =&gt; s a -&gt; s a -&gt; Bool
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; s a -&gt; Bool
</span><a href="M.Collision.Pure.html#intersecting"><span class="hs-identifier hs-var">intersecting</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372239"><span class="hs-identifier hs-var">myself</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372259"><span class="hs-identifier hs-var">block</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-226"></span><span>              </span><span class="hs-comment">-- i am indeed stuck, so i will just exit early</span><span>
</span><span id="line-227"></span><span>              </span><span class="annot"><span class="annottext">EarlyExit n -&gt; Eff ef ()
forall e (es :: [Effect]) a.
(HasCallStack, Exception e) =&gt;
e -&gt; Eff es a
</span><span class="hs-identifier hs-var">throwIO</span></span><span> </span><span class="annot"><span class="annottext">(EarlyExit n -&gt; Eff ef ()) -&gt; EarlyExit n -&gt; Eff ef ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; EarlyExit n
forall a. Resolve a -&gt; EarlyExit a
</span><a href="M.Collision.Effectful.html#EarlyExit"><span class="hs-identifier hs-var">EarlyExit</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372240"><span class="hs-identifier hs-var">resolution</span></a></span><span>
</span><span id="line-228"></span><span>        </span><span class="annot"><span class="annottext">Maybe (s n)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; Eff ef ()
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-comment">-- compute the times (&quot;hits&quot;) at which the object will hit a block</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-comment">-- and then find the earliest hit</span><span>
</span><span id="line-231"></span><span>    </span><span id="local-6989586621680372262"><span class="annot"><a href="#local-6989586621680372262"><span class="hs-identifier hs-var">mearliest</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621680372251"><span class="hs-identifier hs-type">core</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372240"><span class="hs-identifier hs-type">resolution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372239"><span class="hs-identifier hs-type">myself</span></a></span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-comment">-- feed back (or stop)</span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="hs-identifier hs-type">coerce</span></span><span> </span><span class="annot"><a href="#local-6989586621680372262"><span class="hs-identifier hs-type">mearliest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-234"></span><span>      </span><span id="local-6989586621680372263"><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span></span><span>
</span><span id="line-235"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Hit n -&gt; Bool
forall a. (Num a, Ord a) =&gt; Hit a -&gt; Bool
</span><a href="M.Collision.Pure.html#hitin01"><span class="hs-identifier hs-var">hitin01</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-236"></span><span>            </span><span class="hs-comment">-- now correct the displacement; advance position</span><span>
</span><span id="line-237"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680372269"><span class="annot"><span class="annottext">! :: V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372269"><span class="hs-operator hs-var hs-var">(!)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 a -&gt; Rep V3 -&gt; a
forall a. V3 a -&gt; Rep V3 -&gt; a
forall (f :: * -&gt; *) a. Representable f =&gt; f a -&gt; Rep f -&gt; a
</span><span class="hs-identifier hs-var">index</span></span><span>
</span><span id="line-238"></span><span>                </span><span id="local-6989586621680372271"><span class="annot"><span class="annottext">delta :: V3 n
</span><a href="#local-6989586621680372271"><span class="hs-identifier hs-var hs-var">delta</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Hit n -&gt; n
forall a. Hit a -&gt; a
</span><a href="M.Collision.Pure.html#hittime"><span class="hs-identifier hs-var">hittime</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span><span> </span><span class="annot"><span class="annottext">n -&gt; V3 n -&gt; V3 n
forall (f :: * -&gt; *) a. (Functor f, Num a) =&gt; a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">*^</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span>
</span><span id="line-239"></span><span>                </span><span id="local-6989586621680372274"><span class="annot"><span class="annottext">collided :: V3 Bool
</span><a href="#local-6989586621680372274"><span class="hs-identifier hs-var hs-var">collided</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(n -&gt; Bool) -&gt; V3 n -&gt; V3 Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Hit n -&gt; V3 n
forall a. Hit a -&gt; V3 a
</span><a href="M.Collision.Pure.html#hitnorm"><span class="hs-identifier hs-var">hitnorm</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span><span>
</span><span id="line-240"></span><span>                </span><span id="local-6989586621680372276"><span class="annot"><span class="annottext">resdis :: V3 n
</span><a href="#local-6989586621680372276"><span class="hs-identifier hs-var hs-var">resdis</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-241"></span><span>                  </span><span class="annot"><span class="annottext">(Rep V3 -&gt; n) -&gt; V3 n
forall a. (Rep V3 -&gt; a) -&gt; V3 a
forall (f :: * -&gt; *) a. Representable f =&gt; (Rep f -&gt; a) -&gt; f a
</span><span class="hs-identifier hs-var">tabulate</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372278"><span class="annot"><span class="annottext">Rep V3
</span><a href="#local-6989586621680372278"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-242"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">V3 Bool
</span><a href="#local-6989586621680372274"><span class="hs-identifier hs-var">collided</span></a></span><span> </span><span class="annot"><span class="annottext">V3 Bool -&gt; Rep V3 -&gt; Bool
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372269"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
</span><a href="#local-6989586621680372278"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-243"></span><span>                      </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span> </span><span class="hs-comment">-- collision cancels out the displacement</span><span>
</span><span id="line-244"></span><span>                      </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Hit n -&gt; n
forall a. Hit a -&gt; a
</span><a href="M.Collision.Pure.html#hittime"><span class="hs-identifier hs-var">hittime</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Rep V3 -&gt; n
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372269"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
</span><a href="#local-6989586621680372278"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-245"></span><span>                </span><span id="local-6989586621680372280"><span class="annot"><span class="annottext">respos :: V3 n
</span><a href="#local-6989586621680372280"><span class="hs-identifier hs-var hs-var">respos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">s n -&gt; V3 n
forall a. (Fractional a, Ord a) =&gt; s a -&gt; V3 a
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; V3 a
</span><a href="M.Collision.Pure.html#scenter"><span class="hs-identifier hs-var">scenter</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372239"><span class="hs-identifier hs-var">myself</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; V3 n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372271"><span class="hs-identifier hs-var">delta</span></a></span><span>
</span><span id="line-246"></span><span>                </span><span id="local-6989586621680372281"><span class="annot"><span class="annottext">restou :: NewlyTouchingGround
</span><a href="#local-6989586621680372281"><span class="hs-identifier hs-var hs-var">restou</span></a></span></span><span>
</span><span id="line-247"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Hit n -&gt; V3 n
forall a. Hit a -&gt; V3 a
</span><a href="M.Collision.Pure.html#hitnorm"><span class="hs-identifier hs-var">hitnorm</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372263"><span class="hs-identifier hs-var">earliest</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; NewlyTouchingGround
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="hs-comment">-- hit the ground</span><span>
</span><span id="line-248"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; NewlyTouchingGround
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="hs-comment">-- on-ground becomes False</span><span>
</span><span id="line-249"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; NewlyTouchingGround
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span>
</span><span id="line-250"></span><span>                </span><span id="local-6989586621680372282"><span class="annot"><span class="annottext">res :: Resolve n
</span><a href="#local-6989586621680372282"><span class="hs-identifier hs-var hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">V3 n
respos :: V3 n
respos :: V3 n
</span><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var hs-var">respos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">V3 n
resdis :: V3 n
resdis :: V3 n
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var hs-var">resdis</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NewlyTouchingGround
restou :: NewlyTouchingGround
restou :: NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var hs-var">restou</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-251"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">V3 Bool -&gt; Bool
forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><span class="hs-identifier hs-var">or</span></span><span> </span><span class="annot"><span class="annottext">V3 Bool
</span><a href="#local-6989586621680372274"><span class="hs-identifier hs-var">collided</span></a></span><span>
</span><span id="line-252"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 Bool -&gt; Bool
forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><span class="hs-identifier hs-var">and</span></span><span> </span><span class="annot"><span class="annottext">V3 Bool
</span><a href="#local-6989586621680372274"><span class="hs-identifier hs-var">collided</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-253"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n -&gt; Bool
forall a. Epsilon a =&gt; a -&gt; Bool
</span><span class="hs-identifier hs-var">nearZero</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372276"><span class="hs-identifier hs-var">resdis</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-254"></span><span>                  </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">s n -&gt; Resolve n -&gt; Eff ef (Resolve n)
</span><a href="#local-6989586621680372238"><span class="hs-identifier hs-var">cont</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n -&gt; s n -&gt; s n
forall a. Num a =&gt; V3 a -&gt; s a -&gt; s a
forall (s :: * -&gt; *) a. (Shape s, Num a) =&gt; V3 a -&gt; s a -&gt; s a
</span><a href="M.Collision.Pure.html#translate"><span class="hs-identifier hs-var">translate</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372271"><span class="hs-identifier hs-var">delta</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372239"><span class="hs-identifier hs-var">myself</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372282"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-255"></span><span>                  </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; Eff ef (Resolve n)
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Resolve n -&gt; Eff ef (Resolve n))
-&gt; Resolve n -&gt; Eff ef (Resolve n)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372282"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; (Resolve n -&gt; Resolve n) -&gt; Resolve n
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">(V3 n -&gt; Identity (V3 n)) -&gt; Resolve n -&gt; Identity (Resolve n)
forall a (f :: * -&gt; *).
Functor f =&gt;
(V3 a -&gt; f (V3 a)) -&gt; Resolve a -&gt; f (Resolve a)
</span><a href="M.Collision.Effectful.html#_resdis"><span class="hs-identifier hs-var">_resdis</span></a></span><span> </span><span class="annot"><span class="annottext">((V3 n -&gt; Identity (V3 n)) -&gt; Resolve n -&gt; Identity (Resolve n))
-&gt; V3 n -&gt; Resolve n -&gt; Resolve n
forall s t a b. ASetter s t a b -&gt; b -&gt; s -&gt; t
</span><span class="hs-operator hs-var">.~</span></span><span> </span><span class="annot"><span class="annottext">V3 n
forall a. Num a =&gt; V3 a
forall (f :: * -&gt; *) a. (Additive f, Num a) =&gt; f a
</span><span class="hs-identifier hs-var">zero</span></span><span>
</span><span id="line-256"></span><span>      </span><span class="annot"><span class="annottext">Hit n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-257"></span><span>        </span><span class="hs-comment">-- no collision, so apply the displacement</span><span>
</span><span id="line-258"></span><span>        </span><span class="annot"><span class="annottext">Resolve n -&gt; Eff ef (Resolve n)
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-259"></span><span>          </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span>
</span><span id="line-260"></span><span>            </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">respos :: V3 n
</span><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var">respos</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; V3 n
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#respos"><span class="hs-identifier hs-var">respos</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372240"><span class="hs-identifier hs-var">resolution</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; V3 n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-261"></span><span>              </span><span class="annot"><span class="annottext">resdis :: V3 n
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 n
forall a. Num a =&gt; V3 a
forall (f :: * -&gt; *) a. (Additive f, Num a) =&gt; f a
</span><span class="hs-identifier hs-var">zero</span></span><span class="hs-special">,</span><span>
</span><span id="line-262"></span><span>              </span><span class="annot"><span class="annottext">restou :: NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var">restou</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-263"></span><span>                </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372241"><span class="hs-identifier hs-var">disp</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Getting n (V3 n) n -&gt; n
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting n (V3 n) n
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span>
</span><span id="line-264"></span><span>                  </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; NewlyTouchingGround
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="hs-comment">-- on-ground becomes False</span><span>
</span><span id="line-265"></span><span>                  </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; NewlyTouchingGround
forall a. Resolve a -&gt; NewlyTouchingGround
</span><a href="M.Collision.Effectful.html#restou"><span class="hs-identifier hs-var">restou</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372240"><span class="hs-identifier hs-var">resolution</span></a></span><span> </span><span class="hs-comment">-- (inherit previous decision)</span><span>
</span><span id="line-266"></span><span>            </span><span class="hs-special">}</span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span class="hs-comment">-- slow process ... use ray marching from each face point</span><span>
</span><span id="line-269"></span><span class="hs-comment">-- collect all hits found from all rays</span><span>
</span><span id="line-270"></span><span class="annot"><a href="M.Collision.Effectful.html#slowcore"><span class="hs-identifier hs-type">slowcore</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-271"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621680372290"><span class="annot"><a href="#local-6989586621680372290"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621680372291"><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621680372292"><span class="annot"><a href="#local-6989586621680372292"><span class="hs-identifier hs-type">ef</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-272"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Shape"><span class="hs-identifier hs-type">Shape</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372290"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-273"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Epsilon</span></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-274"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">RealFloat</span></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-275"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372290"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680372292"><span class="hs-identifier hs-type">ef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-276"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Reader</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680372292"><span class="hs-identifier hs-type">ef</span></a></span><span>
</span><span id="line-277"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-278"></span><span>  </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680372290"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680372292"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Min</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Pure.html#Hit%27"><span class="hs-identifier hs-type">Hit'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span id="slowcore"><span class="annot"><span class="annottext">slowcore :: forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, Epsilon n, RealFloat n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#slowcore"><span class="hs-identifier hs-var hs-var">slowcore</span></a></span></span><span> </span><span id="local-6989586621680372345"><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372345"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span id="local-6989586621680372346"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372346"><span class="hs-identifier hs-var">myself</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-280"></span><span>  </span><span class="annot"><span class="annottext">forall r (es :: [Effect]).
(HasCallStack, Reader r :&gt; es) =&gt;
Eff es r
</span><span class="hs-identifier hs-var">ask</span></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680372291"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Eff ef [V3 n]
-&gt; ([V3 n] -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef a -&gt; (a -&gt; Eff ef b) -&gt; Eff ef b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372347"><span class="annot"><span class="annottext">[V3 n]
</span><a href="#local-6989586621680372347"><span class="hs-identifier hs-var">fps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-281"></span><span>    </span><span class="annot"><span class="annottext">[Min (Hit' n)] -&gt; Min (Hit' n)
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">([Min (Hit' n)] -&gt; Min (Hit' n))
-&gt; Eff ef [Min (Hit' n)] -&gt; Eff ef (Min (Hit' n))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[V3 n] -&gt; (V3 n -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef [Min (Hit' n)]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">for</span></span><span> </span><span class="annot"><span class="annottext">[V3 n]
</span><a href="#local-6989586621680372347"><span class="hs-identifier hs-var">fps</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372349"><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372349"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-282"></span><span>      </span><span class="hs-comment">-- ray marching algorithm:</span><span>
</span><span id="line-283"></span><span>      </span><span class="hs-comment">--   1. shoot ray from each face point (fp)</span><span>
</span><span id="line-284"></span><span>      </span><span class="hs-comment">--   2. track ray's path through grid cubes</span><span>
</span><span id="line-285"></span><span>      </span><span class="hs-comment">--   3. stop at first hit or when ray length &gt; displacement</span><span>
</span><span id="line-286"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-287"></span><span>      </span><span class="hs-comment">-- grid traversal details:</span><span>
</span><span id="line-288"></span><span>      </span><span class="hs-comment">--   - ray can enter multiple cubes simultaneously:</span><span>
</span><span id="line-289"></span><span>      </span><span class="hs-comment">--     * 1 cube: through face</span><span>
</span><span id="line-290"></span><span>      </span><span class="hs-comment">--     * 2 cubes: through edge (if not parallel to axis)</span><span>
</span><span id="line-291"></span><span>      </span><span class="hs-comment">--     * 3 cubes: through corner</span><span>
</span><span id="line-292"></span><span>      </span><span class="hs-comment">--   - cubes are checked for collision</span><span>
</span><span id="line-293"></span><span>      </span><span class="hs-comment">--   - early exit on first collision</span><span>
</span><span id="line-294"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-295"></span><span>      </span><span class="hs-comment">-- note: behavior unspecified when ray travels exactly</span><span>
</span><span id="line-296"></span><span>      </span><span class="hs-comment">-- along grid edge or plane, but will return something</span><span>
</span><span id="line-297"></span><span>      </span><span class="hs-comment">-- for sake of completeness</span><span>
</span><span id="line-298"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n -&gt; V3 n -&gt; [V3 Int] -&gt; March V3 n
forall (f :: * -&gt; *) a. a -&gt; f a -&gt; [f Int] -&gt; March f a
</span><a href="M.Collision.Internal.March.html#March"><span class="hs-identifier hs-var">March</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">V3 n
forall a. HasCallStack =&gt; a
</span><span class="hs-identifier hs-var">undefined</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">n -&gt; Int
forall b. Integral b =&gt; n -&gt; b
forall a b. (RealFrac a, Integral b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">floor</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Int) -&gt; V3 n -&gt; V3 Int
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372349"><span class="hs-identifier hs-var">fp</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">March V3 n -&gt; [March V3 n] -&gt; [March V3 n]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; [March V3 n]
forall (f :: * -&gt; *) a.
(Foldable f, Representable f, Rep f ~ E f, RealFloat a,
 Epsilon a) =&gt;
f a -&gt; f a -&gt; [March f a]
</span><a href="M.Collision.Internal.March.html#march"><span class="hs-identifier hs-var">march</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372349"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Resolve n -&gt; V3 n
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372345"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>        </span><span class="annot"><span class="annottext">[March V3 n]
-&gt; ([March V3 n] -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef (Min (Hit' n))
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">(([March V3 n] -&gt; Eff ef (Min (Hit' n)))
 -&gt; [March V3 n] -&gt; Eff ef (Min (Hit' n)))
-&gt; [March V3 n] -&gt; Eff ef (Min (Hit' n))
forall a. (a -&gt; a) -&gt; a
</span><span class="hs-identifier hs-var">fix</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372353"><span class="annot"><span class="annottext">[March V3 n] -&gt; Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372353"><span class="hs-identifier hs-var">contrm</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-300"></span><span>          </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-301"></span><span>            </span><span class="hs-comment">-- some improper displacements can cause termination</span><span>
</span><span id="line-302"></span><span>            </span><span class="hs-comment">-- of ray marching (which should normally be infinite)</span><span>
</span><span id="line-303"></span><span>            </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Eff ef (Min (Hit' n))
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Min (Hit' n)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-304"></span><span>            </span><span class="hs-comment">-- no hit</span><span>
</span><span id="line-305"></span><span>            </span><span class="annot"><a href="M.Collision.Internal.March.html#March"><span class="hs-identifier hs-type">March</span></a></span><span> </span><span id="local-6989586621680372354"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621680372354"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[V3 Int]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[March V3 n]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621680372354"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">n -&gt; n -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Eff ef (Min (Hit' n))
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Min (Hit' n)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-306"></span><span>            </span><span class="hs-comment">-- entering (a) grid cube(s), are there any blocks in them?</span><span>
</span><span id="line-307"></span><span>            </span><span class="annot"><a href="M.Collision.Internal.March.html#March"><span class="hs-identifier hs-type">March</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680372355"><span class="annot"><span class="annottext">[V3 Int]
</span><a href="#local-6989586621680372355"><span class="hs-identifier hs-var">cubes</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680372356"><span class="annot"><span class="annottext">[March V3 n]
</span><a href="#local-6989586621680372356"><span class="hs-identifier hs-var">rm</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-308"></span><span>              </span><span class="annot"><span class="annottext">[V3 Int]
</span><a href="#local-6989586621680372355"><span class="hs-identifier hs-var">cubes</span></a></span><span> </span><span class="annot"><span class="annottext">[V3 Int]
-&gt; ([V3 Int] -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef (Min (Hit' n))
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">(([V3 Int] -&gt; Eff ef (Min (Hit' n)))
 -&gt; [V3 Int] -&gt; Eff ef (Min (Hit' n)))
-&gt; [V3 Int] -&gt; Eff ef (Min (Hit' n))
forall a. (a -&gt; a) -&gt; a
</span><span class="hs-identifier hs-var">fix</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372357"><span class="annot"><span class="annottext">[V3 Int] -&gt; Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372357"><span class="hs-identifier hs-var">contcb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-309"></span><span>                </span><span class="hs-comment">-- ran out of grid cubes, so, no;</span><span>
</span><span id="line-310"></span><span>                </span><span class="hs-comment">-- need to go one step further along the ray</span><span>
</span><span id="line-311"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[March V3 n] -&gt; Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372353"><span class="hs-identifier hs-var">contrm</span></a></span><span> </span><span class="annot"><span class="annottext">[March V3 n]
</span><a href="#local-6989586621680372356"><span class="hs-identifier hs-var">rm</span></a></span><span>
</span><span id="line-312"></span><span>                </span><span class="hs-comment">-- let's check the block at the grid cube</span><span>
</span><span id="line-313"></span><span>                </span><span id="local-6989586621680372358"><span class="annot"><span class="annottext">V3 Int
</span><a href="#local-6989586621680372358"><span class="hs-identifier hs-var">cb</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680372359"><span class="annot"><span class="annottext">[V3 Int]
</span><a href="#local-6989586621680372359"><span class="hs-identifier hs-var">cb'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-314"></span><span>                  </span><span class="annot"><span class="annottext">(s n -&gt; Hit n)
-&gt; Eff ef (Min (Hit' n)) -&gt; V3 Int -&gt; Eff ef (Min (Hit' n))
forall (s :: * -&gt; *) n (ef :: [Effect]).
(GetBlock s n :&gt; ef, Shape s, Fractional n, Ord n) =&gt;
(s n -&gt; Hit n)
-&gt; Eff ef (Min (Hit' n)) -&gt; V3 Int -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#chkcol"><span class="hs-identifier hs-var">chkcol</span></a></span><span>
</span><span id="line-315"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n -&gt; s n -&gt; s n -&gt; Hit n
forall a. RealFloat a =&gt; V3 a -&gt; s a -&gt; s a -&gt; Hit a
forall (s :: * -&gt; *) a.
(Shape s, RealFloat a) =&gt;
V3 a -&gt; s a -&gt; s a -&gt; Hit a
</span><a href="M.Collision.Pure.html#hitting"><span class="hs-identifier hs-var">hitting</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Resolve n -&gt; V3 n
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372345"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372346"><span class="hs-identifier hs-var">myself</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-316"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[V3 Int] -&gt; Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372357"><span class="hs-identifier hs-var">contcb</span></a></span><span> </span><span class="annot"><span class="annottext">[V3 Int]
</span><a href="#local-6989586621680372359"><span class="hs-identifier hs-var">cb'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>                    </span><span class="annot"><span class="annottext">V3 Int
</span><a href="#local-6989586621680372358"><span class="hs-identifier hs-var">cb</span></a></span><span>
</span><span id="line-318"></span><span>
</span><span id="line-319"></span><span class="hs-comment">-- fast collision detection for small movements (length &lt;= 1 or</span><span>
</span><span id="line-320"></span><span class="hs-comment">-- diagonal |x|=|z|=1)</span><span>
</span><span id="line-321"></span><span class="hs-comment">--</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- key idea: instead of ray marching, we check potential collision blocks</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- directly by considering the movement box - the space swept by the object</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- during movement</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- algorithm:</span><span>
</span><span id="line-327"></span><span class="hs-comment">--   for each face point of the moving object:</span><span>
</span><span id="line-328"></span><span class="hs-comment">--     1. find start (bef) and end (aft) positions</span><span>
</span><span id="line-329"></span><span class="hs-comment">--     2. generate test points at corners of movement box:</span><span>
</span><span id="line-330"></span><span class="hs-comment">--        - movement box is the space between bef and aft positions</span><span>
</span><span id="line-331"></span><span class="hs-comment">--        - use binary counting (0-7) to pick coordinates:</span><span>
</span><span id="line-332"></span><span class="hs-comment">--          * bit 0 = x: choose between bef.x (0) or aft.x (1)</span><span>
</span><span id="line-333"></span><span class="hs-comment">--          * bit 1 = y: choose between bef.y (0) or aft.y (1)</span><span>
</span><span id="line-334"></span><span class="hs-comment">--          * bit 2 = z: choose between bef.z (0) or aft.z (1)</span><span>
</span><span id="line-335"></span><span class="hs-comment">--        - skip coordinates where movement is negligible</span><span>
</span><span id="line-336"></span><span class="hs-comment">--     3. for each test point:</span><span>
</span><span id="line-337"></span><span class="hs-comment">--        - get block at that position</span><span>
</span><span id="line-338"></span><span class="hs-comment">--        - test if moving object would hit that block</span><span>
</span><span id="line-339"></span><span class="hs-comment">--        - collect all hits found</span><span>
</span><span id="line-340"></span><span class="hs-comment">--</span><span>
</span><span id="line-341"></span><span class="hs-comment">-- example: moving +X+Y (need = &lt;True,True,False&gt;)</span><span>
</span><span id="line-342"></span><span class="hs-comment">--   we only check 4 corners instead of 8 since Z movement = 0:</span><span>
</span><span id="line-343"></span><span class="hs-comment">--   * 000 -&gt; (bef.x, bef.y, bef.z)</span><span>
</span><span id="line-344"></span><span class="hs-comment">--   * 001 -&gt; (aft.x, bef.y, bef.z)</span><span>
</span><span id="line-345"></span><span class="hs-comment">--   * 010 -&gt; (bef.x, aft.y, bef.z)</span><span>
</span><span id="line-346"></span><span class="hs-comment">--   * 011 -&gt; (aft.x, aft.y, bef.z)</span><span>
</span><span id="line-347"></span><span class="annot"><a href="M.Collision.Effectful.html#fastcore"><span class="hs-identifier hs-type">fastcore</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-348"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621680371499"><span class="annot"><a href="#local-6989586621680371499"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621680371500"><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621680371501"><span class="annot"><a href="#local-6989586621680371501"><span class="hs-identifier hs-type">ef</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-349"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Shape"><span class="hs-identifier hs-type">Shape</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371499"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-350"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Epsilon</span></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">RealFloat</span></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-352"></span><span>    </span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371499"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371501"><span class="hs-identifier hs-type">ef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-353"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Reader</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371501"><span class="hs-identifier hs-type">ef</span></a></span><span>
</span><span id="line-354"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-355"></span><span>  </span><span class="annot"><a href="M.Collision.Effectful.html#Resolve"><span class="hs-identifier hs-type">Resolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680371499"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371501"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Min</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Pure.html#Hit%27"><span class="hs-identifier hs-type">Hit'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-356"></span><span id="fastcore"><span class="annot"><span class="annottext">fastcore :: forall (s :: * -&gt; *) n (ef :: [Effect]).
(Shape s, Epsilon n, RealFloat n, GetBlock s n :&gt; ef,
 Reader [V3 n] :&gt; ef) =&gt;
Resolve n -&gt; s n -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#fastcore"><span class="hs-identifier hs-var hs-var">fastcore</span></a></span></span><span> </span><span id="local-6989586621680372417"><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372417"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span id="local-6989586621680372418"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372418"><span class="hs-identifier hs-var">myself</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-357"></span><span>  </span><span class="annot"><span class="annottext">forall r (es :: [Effect]).
(HasCallStack, Reader r :&gt; es) =&gt;
Eff es r
</span><span class="hs-identifier hs-var">ask</span></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><a href="#local-6989586621680371500"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- face points (world coordinates)</span><span>
</span><span id="line-358"></span><span>    </span><span class="annot"><span class="annottext">Eff ef [V3 n]
-&gt; ([V3 n] -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef a -&gt; (a -&gt; Eff ef b) -&gt; Eff ef b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">([[Min (Hit' n)]] -&gt; Min (Hit' n))
-&gt; Eff ef [[Min (Hit' n)]] -&gt; Eff ef (Min (Hit' n))
forall a b. (a -&gt; b) -&gt; Eff ef a -&gt; Eff ef b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Min (Hit' n)] -&gt; Min (Hit' n)
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">([Min (Hit' n)] -&gt; Min (Hit' n))
-&gt; ([[Min (Hit' n)]] -&gt; [Min (Hit' n)])
-&gt; [[Min (Hit' n)]]
-&gt; Min (Hit' n)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[[Min (Hit' n)]] -&gt; [Min (Hit' n)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Eff ef [[Min (Hit' n)]] -&gt; Eff ef (Min (Hit' n)))
-&gt; ([V3 n] -&gt; Eff ef [[Min (Hit' n)]])
-&gt; [V3 n]
-&gt; Eff ef (Min (Hit' n))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(V3 n -&gt; Eff ef [Min (Hit' n)])
-&gt; [V3 n] -&gt; Eff ef [[Min (Hit' n)]]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680372421"><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372421"><span class="hs-identifier hs-var">bef</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-359"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680372422"><span class="annot"><span class="annottext">dis :: V3 n
</span><a href="#local-6989586621680372422"><span class="hs-identifier hs-var hs-var">dis</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Resolve n -&gt; V3 n
forall a. Resolve a -&gt; V3 a
</span><a href="M.Collision.Effectful.html#resdis"><span class="hs-identifier hs-var">resdis</span></a></span><span> </span><span class="annot"><span class="annottext">Resolve n
</span><a href="#local-6989586621680372417"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-360"></span><span>          </span><span id="local-6989586621680372423"><span class="annot"><span class="annottext">aft :: V3 n
</span><a href="#local-6989586621680372423"><span class="hs-identifier hs-var hs-var">aft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372421"><span class="hs-identifier hs-var">bef</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; V3 n -&gt; V3 n
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372422"><span class="hs-identifier hs-var">dis</span></a></span><span> </span><span class="hs-comment">-- before (bef) and after (aft) positions</span><span>
</span><span id="line-361"></span><span>          </span><span class="hs-comment">-- moving in {x,y,z} directions?</span><span>
</span><span id="line-362"></span><span>          </span><span id="local-6989586621680372424"><span class="annot"><span class="annottext">need :: V3 Bool
</span><a href="#local-6989586621680372424"><span class="hs-identifier hs-var hs-var">need</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (n -&gt; Bool) -&gt; n -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; Bool
forall a. Epsilon a =&gt; a -&gt; Bool
</span><span class="hs-identifier hs-var">nearZero</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Bool) -&gt; V3 n -&gt; V3 Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372422"><span class="hs-identifier hs-var">dis</span></a></span><span>
</span><span id="line-363"></span><span>          </span><span class="hs-comment">-- note: chkcol uses continuation-passing to collect hits</span><span>
</span><span id="line-364"></span><span>          </span><span class="hs-comment">-- we use 'pure mempty' as the final continuation</span><span>
</span><span id="line-365"></span><span>          </span><span id="local-6989586621680372425"><span class="annot"><span class="annottext">hits :: Eff ef [Min (Hit' n)]
</span><a href="#local-6989586621680372425"><span class="hs-identifier hs-var hs-var">hits</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[V3 Int]
-&gt; (V3 Int -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef [Min (Hit' n)]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">for</span></span><span> </span><span class="annot"><span class="annottext">[V3 Int]
</span><a href="#local-6989586621680372426"><span class="hs-identifier hs-var">targets</span></a></span><span> </span><span class="annot"><span class="annottext">((V3 Int -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef [Min (Hit' n)])
-&gt; (V3 Int -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef [Min (Hit' n)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(s n -&gt; Hit n)
-&gt; Eff ef (Min (Hit' n)) -&gt; V3 Int -&gt; Eff ef (Min (Hit' n))
forall (s :: * -&gt; *) n (ef :: [Effect]).
(GetBlock s n :&gt; ef, Shape s, Fractional n, Ord n) =&gt;
(s n -&gt; Hit n)
-&gt; Eff ef (Min (Hit' n)) -&gt; V3 Int -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#chkcol"><span class="hs-identifier hs-var">chkcol</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 n -&gt; s n -&gt; s n -&gt; Hit n
forall a. RealFloat a =&gt; V3 a -&gt; s a -&gt; s a -&gt; Hit a
forall (s :: * -&gt; *) a.
(Shape s, RealFloat a) =&gt;
V3 a -&gt; s a -&gt; s a -&gt; Hit a
</span><a href="M.Collision.Pure.html#hitting"><span class="hs-identifier hs-var">hitting</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372422"><span class="hs-identifier hs-var">dis</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372418"><span class="hs-identifier hs-var">myself</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Eff ef (Min (Hit' n))
forall a. a -&gt; Eff ef a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Min (Hit' n)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-366"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-367"></span><span>              </span><span id="local-6989586621680372430"><span class="annot"><span class="annottext">! :: V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372430"><span class="hs-operator hs-var hs-var">(!)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 a -&gt; Rep V3 -&gt; a
forall a. V3 a -&gt; Rep V3 -&gt; a
forall (f :: * -&gt; *) a. Representable f =&gt; f a -&gt; Rep f -&gt; a
</span><span class="hs-identifier hs-var">index</span></span><span>
</span><span id="line-368"></span><span>              </span><span class="hs-comment">-- select position component (bef/aft) based on bit</span><span>
</span><span id="line-369"></span><span>              </span><span id="local-6989586621680372431"><span class="annot"><span class="annottext">pos :: Int -&gt; E V3 -&gt; n
</span><a href="#local-6989586621680372431"><span class="hs-identifier hs-var hs-var">pos</span></a></span></span><span> </span><span id="local-6989586621680372432"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680372432"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621680372433"><span class="annot"><span class="annottext">E V3
</span><a href="#local-6989586621680372433"><span class="hs-identifier hs-var">i</span></a></span></span><span>
</span><span id="line-370"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">V3 Bool
</span><a href="#local-6989586621680372424"><span class="hs-identifier hs-var">need</span></a></span><span> </span><span class="annot"><span class="annottext">V3 Bool -&gt; Rep V3 -&gt; Bool
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372430"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
E V3
</span><a href="#local-6989586621680372433"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Bits a =&gt; a -&gt; Int -&gt; Bool
</span><span class="hs-identifier hs-var">testBit</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680372432"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int -&gt; V3 Int
forall a. a -&gt; a -&gt; a -&gt; V3 a
</span><span class="hs-identifier hs-var">V3</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">V3 Int -&gt; Rep V3 -&gt; Int
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372430"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
E V3
</span><a href="#local-6989586621680372433"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372423"><span class="hs-identifier hs-var">aft</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Rep V3 -&gt; n
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372430"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
E V3
</span><a href="#local-6989586621680372433"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-371"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V3 n
</span><a href="#local-6989586621680372421"><span class="hs-identifier hs-var">bef</span></a></span><span> </span><span class="annot"><span class="annottext">V3 n -&gt; Rep V3 -&gt; n
forall a. V3 a -&gt; Rep V3 -&gt; a
</span><a href="#local-6989586621680372430"><span class="hs-operator hs-var">!</span></a></span><span> </span><span class="annot"><span class="annottext">Rep V3
E V3
</span><a href="#local-6989586621680372433"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-372"></span><span>              </span><span class="hs-comment">-- see \#2 in the algorithm description</span><span>
</span><span id="line-373"></span><span>              </span><span id="local-6989586621680372426"><span class="annot"><span class="annottext">targets :: [V3 Int]
</span><a href="#local-6989586621680372426"><span class="hs-identifier hs-var hs-var">targets</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[V3 Int] -&gt; [V3 Int]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">([V3 Int] -&gt; [V3 Int]) -&gt; [V3 Int] -&gt; [V3 Int]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(n -&gt; Int) -&gt; V3 n -&gt; V3 Int
forall a b. (a -&gt; b) -&gt; V3 a -&gt; V3 b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">n -&gt; Int
forall b. Integral b =&gt; n -&gt; b
forall a b. (RealFrac a, Integral b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">floor</span></span><span> </span><span class="annot"><span class="annottext">(V3 n -&gt; V3 Int) -&gt; (Int -&gt; V3 n) -&gt; Int -&gt; V3 Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Rep V3 -&gt; n) -&gt; V3 n
(E V3 -&gt; n) -&gt; V3 n
forall a. (Rep V3 -&gt; a) -&gt; V3 a
forall (f :: * -&gt; *) a. Representable f =&gt; (Rep f -&gt; a) -&gt; f a
</span><span class="hs-identifier hs-var">tabulate</span></span><span> </span><span class="annot"><span class="annottext">((E V3 -&gt; n) -&gt; V3 n) -&gt; (Int -&gt; E V3 -&gt; n) -&gt; Int -&gt; V3 n
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; E V3 -&gt; n
</span><a href="#local-6989586621680372431"><span class="hs-identifier hs-var">pos</span></a></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; V3 Int) -&gt; [Int] -&gt; [V3 Int]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
Item [Int]
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">]</span><span>
</span><span id="line-374"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Eff ef [Min (Hit' n)]
</span><a href="#local-6989586621680372425"><span class="hs-identifier hs-var">hits</span></a></span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span class="hs-comment">-- internal helper function for 'resolve'</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- check if i hit a block at the grid cube (and check below for tall blocks)</span><span>
</span><span id="line-378"></span><span id="local-6989586621680371564"><span id="local-6989586621680371565"><span id="local-6989586621680371566"><span class="annot"><a href="M.Collision.Effectful.html#chkcol"><span class="hs-identifier hs-type">chkcol</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-379"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Effectful.html#GetBlock"><span class="hs-identifier hs-type">GetBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371564"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680371566"><span class="hs-identifier hs-type">ef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Shape"><span class="hs-identifier hs-type">Shape</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371564"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-380"></span><span>  </span><span class="hs-comment">-- check for hit given block shape (shape has absolute coordinates)</span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680371564"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="M.Collision.Pure.html#Hit"><span class="hs-identifier hs-type">Hit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-382"></span><span>  </span><span class="hs-comment">-- continuation for continuing to next grid cube</span><span>
</span><span id="line-383"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371566"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Min</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Pure.html#Hit%27"><span class="hs-identifier hs-type">Hit'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-384"></span><span>  </span><span class="hs-comment">-- where (block coordinates)</span><span>
</span><span id="line-385"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">V3</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-386"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680371566"><span class="hs-identifier hs-type">ef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Min</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="M.Collision.Pure.html#Hit%27"><span class="hs-identifier hs-type">Hit'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680371565"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-387"></span><span id="chkcol"><span class="annot"><span class="annottext">chkcol :: forall (s :: * -&gt; *) n (ef :: [Effect]).
(GetBlock s n :&gt; ef, Shape s, Fractional n, Ord n) =&gt;
(s n -&gt; Hit n)
-&gt; Eff ef (Min (Hit' n)) -&gt; V3 Int -&gt; Eff ef (Min (Hit' n))
</span><a href="M.Collision.Effectful.html#chkcol"><span class="hs-identifier hs-var hs-var">chkcol</span></a></span></span><span> </span><span id="local-6989586621680372476"><span class="annot"><span class="annottext">s n -&gt; Hit n
</span><a href="#local-6989586621680372476"><span class="hs-identifier hs-var">chkhit</span></a></span></span><span> </span><span id="local-6989586621680372477"><span class="annot"><span class="annottext">Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372477"><span class="hs-identifier hs-var">continue</span></a></span></span><span> </span><span id="local-6989586621680372478"><span class="annot"><span class="annottext">V3 Int
</span><a href="#local-6989586621680372478"><span class="hs-identifier hs-var">cb</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680372479"><span class="annot"><span class="annottext">chkbelow :: Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
</span><a href="#local-6989586621680372479"><span class="hs-identifier hs-var hs-var">chkbelow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-389"></span><span>        </span><span class="hs-comment">-- go below and check too</span><span>
</span><span id="line-390"></span><span>        </span><span class="annot"><span class="annottext">V3 Int -&gt; Eff ef (Maybe (s n))
forall (f :: * -&gt; *) a (ef :: [Effect]).
(HasCallStack, GetBlock f a :&gt; ef) =&gt;
V3 Int -&gt; Eff ef (Maybe (f a))
</span><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier hs-var">getblock</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">V3 Int
</span><a href="#local-6989586621680372478"><span class="hs-identifier hs-var">cb</span></a></span><span> </span><span class="annot"><span class="annottext">V3 Int -&gt; (V3 Int -&gt; V3 Int) -&gt; V3 Int
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Identity Int) -&gt; V3 Int -&gt; Identity (V3 Int)
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span> </span><span class="annot"><span class="annottext">((Int -&gt; Identity Int) -&gt; V3 Int -&gt; Identity (V3 Int))
-&gt; Int -&gt; V3 Int -&gt; V3 Int
forall a s t. Num a =&gt; ASetter s t a a -&gt; a -&gt; s -&gt; t
</span><span class="hs-operator hs-var">-~</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Eff ef (Maybe (s n))
-&gt; (Maybe (s n) -&gt; Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;&amp;&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-391"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680372482"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372482"><span class="hs-identifier hs-var">blockbelow</span></a></span></span><span>
</span><span id="line-392"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680372483"><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372483"><span class="hs-identifier hs-var">hit</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">s n -&gt; Hit n
</span><a href="#local-6989586621680372476"><span class="hs-identifier hs-var">chkhit</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372482"><span class="hs-identifier hs-var">blockbelow</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-393"></span><span>              </span><span class="annot"><span class="annottext">Hit n -&gt; Bool
forall a. (Num a, Ord a) =&gt; Hit a -&gt; Bool
</span><a href="M.Collision.Pure.html#hitin01"><span class="hs-identifier hs-var">hitin01</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372483"><span class="hs-identifier hs-var">hit</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-394"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Hit n -&gt; Min (Hit' n)
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372483"><span class="hs-identifier hs-var">hit</span></a></span><span> </span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Min (Hit' n) -&gt; Min (Hit' n)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span>
</span><span id="line-395"></span><span>          </span><span class="annot"><span class="annottext">Maybe (s n)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Min (Hit' n)
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-396"></span><span>      </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621680372479"><span class="hs-pragma hs-type">chkbelow</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-397"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span id="local-6989586621680372490"><span class="annot"><span class="annottext">? :: Bool -&gt; f (a -&gt; a) -&gt; f (a -&gt; a)
</span><a href="#local-6989586621680372490"><span class="hs-operator hs-var hs-var">?</span></a></span></span><span> </span><span id="local-6989586621680372491"><span class="annot"><span class="annottext">f (a -&gt; a)
</span><a href="#local-6989586621680372491"><span class="hs-identifier hs-var">action</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f (a -&gt; a)
</span><a href="#local-6989586621680372491"><span class="hs-identifier hs-var">action</span></a></span><span>
</span><span id="line-398"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><a href="#local-6989586621680372490"><span class="hs-operator hs-var">?</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; f (a -&gt; a)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-399"></span><span>      </span><span id="local-6989586621680372506"><span class="annot"><span class="annottext">short :: s a -&gt; Bool
</span><a href="#local-6989586621680372506"><span class="hs-identifier hs-var hs-var">short</span></a></span></span><span> </span><span id="local-6989586621680372507"><span class="annot"><span class="annottext">s a
</span><a href="#local-6989586621680372507"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">s a -&gt; V3 a
forall (s :: * -&gt; *) a.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; V3 a
</span><a href="M.Collision.Pure.html#shicorner"><span class="hs-identifier hs-var">shicorner</span></a></span><span> </span><span class="annot"><span class="annottext">s a
</span><a href="#local-6989586621680372507"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">V3 a -&gt; Getting a (V3 a) a -&gt; a
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Getting a (V3 a) a
forall a. Lens' (V3 a) a
forall (t :: * -&gt; *) a. R2 t =&gt; Lens' (t a) a
</span><span class="hs-identifier hs-var">_y</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0.5</span></span><span>
</span><span id="line-400"></span><span>  </span><span class="hs-comment">-- check if a block exists at the grid cube &amp; is solid</span><span>
</span><span id="line-401"></span><span>  </span><span class="hs-comment">-- also just in case a tall block (like a fence)</span><span>
</span><span id="line-402"></span><span>  </span><span class="hs-comment">-- is there, we check the block below it</span><span>
</span><span id="line-403"></span><span>  </span><span class="annot"><span class="annottext">V3 Int -&gt; Eff ef (Maybe (s n))
forall (f :: * -&gt; *) a (ef :: [Effect]).
(HasCallStack, GetBlock f a :&gt; ef) =&gt;
V3 Int -&gt; Eff ef (Maybe (f a))
</span><a href="M.Collision.Effectful.html#getblock"><span class="hs-identifier hs-var">getblock</span></a></span><span> </span><span class="annot"><span class="annottext">V3 Int
</span><a href="#local-6989586621680372478"><span class="hs-identifier hs-var">cb</span></a></span><span> </span><span class="annot"><span class="annottext">Eff ef (Maybe (s n))
-&gt; (Maybe (s n) -&gt; Eff ef (Min (Hit' n))) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef a -&gt; (a -&gt; Eff ef b) -&gt; Eff ef b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-404"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680372509"><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372509"><span class="hs-identifier hs-var">block</span></a></span></span><span>
</span><span id="line-405"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680372510"><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372510"><span class="hs-identifier hs-var">hit</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">s n -&gt; Hit n
</span><a href="#local-6989586621680372476"><span class="hs-identifier hs-var">chkhit</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372509"><span class="hs-identifier hs-var">block</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-406"></span><span>        </span><span class="annot"><span class="annottext">Hit n -&gt; Bool
forall a. (Num a, Ord a) =&gt; Hit a -&gt; Bool
</span><a href="M.Collision.Pure.html#hitin01"><span class="hs-identifier hs-var">hitin01</span></a></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372510"><span class="hs-identifier hs-var">hit</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-407"></span><span>          </span><span class="hs-comment">-- oh, we hit something</span><span>
</span><span id="line-408"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">s n -&gt; Bool
forall {s :: * -&gt; *} {a}.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; Bool
</span><a href="#local-6989586621680372506"><span class="hs-identifier hs-var">short</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372509"><span class="hs-identifier hs-var">block</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
forall {f :: * -&gt; *} {a}.
Applicative f =&gt;
Bool -&gt; f (a -&gt; a) -&gt; f (a -&gt; a)
</span><a href="#local-6989586621680372490"><span class="hs-operator hs-var">?</span></a></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
</span><a href="#local-6989586621680372479"><span class="hs-identifier hs-var">chkbelow</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n)) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef (a -&gt; b) -&gt; Eff ef a -&gt; Eff ef b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Hit n -&gt; Min (Hit' n)
forall a b. Coercible a b =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">coerce</span></span><span> </span><span class="annot"><span class="annottext">Hit n
</span><a href="#local-6989586621680372510"><span class="hs-identifier hs-var">hit</span></a></span><span> </span><span class="annot"><span class="annottext">Min (Hit' n) -&gt; Min (Hit' n) -&gt; Min (Hit' n)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n)) -&gt; Eff ef (Min (Hit' n))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372477"><span class="hs-identifier hs-var">continue</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-409"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-410"></span><span>          </span><span class="hs-comment">-- a block is there but we don't hit it</span><span>
</span><span id="line-411"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">s n -&gt; Bool
forall {s :: * -&gt; *} {a}.
(Shape s, Fractional a, Ord a) =&gt;
s a -&gt; Bool
</span><a href="#local-6989586621680372506"><span class="hs-identifier hs-var">short</span></a></span><span> </span><span class="annot"><span class="annottext">s n
</span><a href="#local-6989586621680372509"><span class="hs-identifier hs-var">block</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
forall {f :: * -&gt; *} {a}.
Applicative f =&gt;
Bool -&gt; f (a -&gt; a) -&gt; f (a -&gt; a)
</span><a href="#local-6989586621680372490"><span class="hs-operator hs-var">?</span></a></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
</span><a href="#local-6989586621680372479"><span class="hs-identifier hs-var">chkbelow</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n)) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef (a -&gt; b) -&gt; Eff ef a -&gt; Eff ef b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372477"><span class="hs-identifier hs-var">continue</span></a></span><span>
</span><span id="line-412"></span><span>    </span><span class="hs-comment">-- no block at the grid cube</span><span>
</span><span id="line-413"></span><span>    </span><span class="annot"><span class="annottext">Maybe (s n)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
</span><a href="#local-6989586621680372479"><span class="hs-identifier hs-var">chkbelow</span></a></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n) -&gt; Min (Hit' n))
-&gt; Eff ef (Min (Hit' n)) -&gt; Eff ef (Min (Hit' n))
forall a b. Eff ef (a -&gt; b) -&gt; Eff ef a -&gt; Eff ef b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Eff ef (Min (Hit' n))
</span><a href="#local-6989586621680372477"><span class="hs-identifier hs-var">continue</span></a></span><span>
</span><span id="line-414"></span></pre></body></html>